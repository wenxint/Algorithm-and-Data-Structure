# 第9章：并查集 - 练习题

本章练习题重点考查并查集的基础操作、动态连通性问题和图论应用。通过这些题目可以深入理解并查集的核心思想和优化技术。

---

## 题目1：朋友圈数量

### 题目描述

班级里有 `n` 个学生，编号从 `0` 到 `n-1`。给定一个 `n x n` 的矩阵 `isConnected`，其中 `isConnected[i][j] = 1` 表示第 `i` 个学生和第 `j` 个学生直接相识，`isConnected[i][j] = 0` 表示不直接相识。

朋友圈是指一群直接或间接相识的学生。求朋友圈的总数。

### 核心思想

这是一个典型的连通分量统计问题。每个朋友圈就是一个连通分量，我们需要：
1. 使用并查集维护学生之间的朋友关系
2. 遍历邻接矩阵，合并直接相识的学生
3. 最终并查集中连通分量的数量就是朋友圈数量

关键点：
- 并查集的基础应用
- 连通分量计数
- 矩阵遍历优化（只需遍历上三角）

### 示例

```
输入: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出: 2
解释: 学生0和学生1是朋友，学生2自己一个朋友圈，所以总共2个朋友圈
```

### 要求

1. 实现基于并查集的解法
2. 分析时间复杂度和空间复杂度
3. 考虑矩阵的对称性进行优化

### 学习要点

- 并查集的基本使用模式
- 连通分量计数的标准方法
- 从图的邻接矩阵到并查集的映射

---

## 题目2：岛屿数量II

### 题目描述

给定一个 `m x n` 的网格，初始时所有格子都是水。现在按顺序执行一系列操作，每次操作将一个水格子变成陆地。求每次操作后岛屿的数量。

陆地格子如果在四个方向上相邻，则属于同一个岛屿。

### 核心思想

这是动态连通性问题的经典应用：
1. 使用并查集维护陆地的连通性
2. 每次添加陆地时，岛屿数量先增加1
3. 然后检查四个方向的邻居，如果是陆地且不在同一连通分量中，则合并并减少岛屿数量
4. 每次合并操作都会减少一个连通分量

关键优化：
- 二维坐标到一维索引的映射
- 只对陆地格子使用并查集操作
- 实时维护岛屿计数

### 示例

```
输入: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出: [1,1,2,3]
解释:
- 添加[0,0]: 1个岛屿
- 添加[0,1]: 与[0,0]相邻，仍然1个岛屿
- 添加[1,2]: 新岛屿，2个岛屿
- 添加[2,1]: 新岛屿，3个岛屿
```

### 要求

1. 实现动态岛屿计数算法
2. 处理边界条件和重复操作
3. 优化空间使用（不需要存储整个网格）

### 学习要点

- 动态连通性的实时维护
- 二维问题的一维映射技巧
- 并查集在在线算法中的应用

---

## 题目3：省份数量（带权重关系）

### 题目描述

有 `n` 个城市，给定一些城市间的距离信息。如果两个城市的距离小于等于 `threshold`，则它们属于同一个省份。同时，如果城市A和城市B属于同一省份，城市B和城市C也属于同一省份，那么城市A和城市C也属于同一省份。

给定距离信息 `distances`，其中 `distances[i] = [cityA, cityB, distance]`，求有多少个省份。

### 核心思想

这是带权重的连通性问题：
1. 使用带权重的并查集或标准并查集
2. 遍历所有距离信息，如果距离小于等于阈值，就合并两个城市
3. 最终统计连通分量数量

扩展思考：
- 如果要查询任意两个城市间的最短距离怎么办？
- 如何处理距离信息的动态更新？

### 示例

```
输入: n = 4, threshold = 4, distances = [[0,1,3],[1,2,5],[2,3,3],[0,3,7]]
输出: 2
解释: 城市0-1距离3≤4相连，城市2-3距离3≤4相连，城市1-2距离5>4不相连
所以形成两个省份：{0,1} 和 {2,3}
```

### 要求

1. 实现基于阈值的连通性判断
2. 考虑使用加权并查集维护距离信息
3. 分析不同阈值对省份划分的影响

### 学习要点

- 条件连通性的处理
- 权重信息在并查集中的应用
- 阈值参数对结果的影响分析

---

## 题目4：账户合并

### 题目描述

给定一些账户信息，每个账户包含账户名和一个邮箱列表。如果两个账户有相同的邮箱，则这两个账户属于同一人。请合并属于同一人的所有账户。

返回格式：每个合并后的账户包含账户名（第一个元素）和按字典序排列的邮箱列表。

### 核心思想

这是一个基于共同元素的连通性问题：
1. 将每个邮箱看作一个节点，建立邮箱到账户的映射
2. 如果两个邮箱属于同一个账户，则在并查集中合并它们
3. 最后按连通分量重新组织账户信息

关键技巧：
- 使用邮箱作为并查集的节点而不是账户
- 建立邮箱到账户名的映射关系
- 结果需要按字典序排序

### 示例

```
输入: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],
                  ["John","johnsmith@mail.com","john00@mail.com"],
                  ["Mary","mary@mail.com"],
                  ["John","johnnybravo@mail.com"]]
输出: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],
       ["Mary","mary@mail.com"],
       ["John","johnnybravo@mail.com"]]
```

### 要求

1. 实现邮箱级别的并查集操作
2. 正确处理账户名的映射
3. 结果按要求格式化和排序

### 学习要点

- 非数值元素的并查集处理
- 复杂映射关系的维护
- 并查集结果的后处理技巧

---

## 题目5：冗余连接

### 题目描述

在一个有 `n` 个节点的无向图中，给定一些边的信息。现在这个图有一条多余的边，使得图中存在环。请找出这条可以删除的边，使得删除后的图仍然连通且无环（即形成一棵树）。

如果有多条边可以删除，返回在输入中最后出现的那条边。

### 核心思想

这是环检测的经典应用：
1. 按顺序遍历所有边
2. 对于每条边，检查两个端点是否已经连通
3. 如果已经连通，说明添加这条边会形成环，这就是要删除的边
4. 如果不连通，则在并查集中合并这两个节点

算法的正确性：
- 树有n个节点n-1条边的性质
- 第一条造成环的边就是多余的边
- 按顺序检查保证找到最后出现的冗余边

### 示例

```
输入: edges = [[1,2],[1,3],[2,3]]
输出: [2,3]
解释: 添加边[1,2]和[1,3]后，节点1,2,3已连通，再添加[2,3]会形成环
```

### 要求

1. 实现基于并查集的环检测算法
2. 确保返回最后出现的冗余边
3. 处理节点编号从1开始的情况

### 学习要点

- 并查集在环检测中的应用
- 在线算法的设计思想
- 贪心选择的正确性证明

---

## 总结

### 难度分布
- **简单题**：题目1（基础连通分量统计）
- **中等题**：题目2、3、5（动态连通性、条件连通、环检测）
- **中等偏难**：题目4（复杂映射关系处理）

### 核心知识点
1. **基础并查集操作**：查找、合并、连通性判断
2. **动态连通性**：实时维护连通分量数量
3. **环检测**：利用并查集检测图中的环
4. **复杂映射**：非数值元素的并查集处理
5. **优化技巧**：路径压缩、按秩合并、空间优化

### 解题策略
- **识别问题类型**：连通性、分组、环检测
- **选择合适的并查集变种**：标准、加权、动态
- **注意边界条件**：空输入、重复操作、特殊格式
- **优化实现**：二维映射、内存使用、时间复杂度 