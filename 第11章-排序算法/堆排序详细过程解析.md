# 堆排序详细过程解析

## 核心思想 🎯

堆排序是一种基于**堆**这种数据结构的比较排序算法。它的核心思想是：

1. **利用堆的特性**：最大堆的根节点总是最大元素
2. **分两阶段完成排序**：
   - 建堆阶段：将无序数组构造成最大堆
   - 排序阶段：反复提取堆顶最大元素并重新调整堆

堆排序巧妙地将"选择最大元素"的操作优化到O(log n)，从而实现整体O(n log n)的时间复杂度。

## 算法核心概念

### 堆的定义
堆是一种特殊的完全二叉树，分为：
- **最大堆**：父节点的值总是大于等于子节点的值
- **最小堆**：父节点的值总是小于等于子节点的值

### 数组表示堆
对于数组索引从0开始的堆：
- 父节点索引：`(i - 1) / 2`
- 左子节点索引：`2 * i + 1`
- 右子节点索引：`2 * i + 2`

```
数组: [50, 30, 40, 10, 20, 35, 25]
堆的树形结构：
        50
       /  \
      30   40
     / |   | \
    10 20 35 25
```

## 算法步骤详解

### 第一阶段：建堆(Heapify)

**目标**：将无序数组转换为最大堆

**策略**：从最后一个非叶子节点开始，向上逐个调整每个节点

```javascript
/**
 * 建堆过程
 * 从最后一个非叶子节点开始向下调整
 */
function buildMaxHeap(arr) {
    const n = arr.length;
    // 最后一个非叶子节点的索引
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```

### 第二阶段：排序

**目标**：反复提取堆顶最大元素，放到已排序区域

**策略**：
1. 将堆顶元素与末尾元素交换
2. 缩小堆的范围
3. 重新调整堆

```javascript
/**
 * 堆排序主函数
 */
function heapSort(arr) {
    const n = arr.length;

    // 第一阶段：建堆
    buildMaxHeap(arr);

    // 第二阶段：排序
    for (let i = n - 1; i > 0; i--) {
        // 将堆顶最大元素交换到末尾
        [arr[0], arr[i]] = [arr[i], arr[0]];

        // 重新调整堆（堆大小减1）
        heapify(arr, i, 0);
    }

    return arr;
}
```

## 核心函数：heapify（向下调整）

**作用**：维护堆的性质，将可能违反堆性质的节点向下调整到正确位置

```javascript
/**
 * 向下调整维护堆性质
 * @param {Array} arr - 数组
 * @param {number} heapSize - 堆的大小
 * @param {number} i - 要调整的节点索引
 */
function heapify(arr, heapSize, i) {
    let largest = i;        // 假设当前节点最大
    let left = 2 * i + 1;   // 左子节点
    let right = 2 * i + 2;  // 右子节点

    // 与左子节点比较
    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }

    // 与右子节点比较
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果最大值不是当前节点，则交换并递归调整
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, heapSize, largest);
    }
}
```

## 详细执行过程示例

以数组 `[4, 10, 3, 5, 1]` 为例演示完整过程：

### 初始状态
```
数组: [4, 10, 3, 5, 1]
树形结构：
    4
   / \
  10  3
 / \
5   1
```

### 第一阶段：建堆

**步骤1：调整节点1（值为10）**
```
调整前：
    4
   / \
  10  3    ← 节点1的子树已经是堆
 / \
5   1

调整后：无需调整，因为10 > 5 且 10 > 1
```

**步骤2：调整节点0（值为4）**
```
调整前：
    4         ← 需要调整，因为4 < 10
   / \
  10  3
 / \
5   1

第一次调整：4与10交换
   10
   / \
   4  3
  / \
 5   1

继续调整：4与5交换
   10
   / \
   5  3
  / \
 4   1

建堆完成！
```

**建堆结果**：`[10, 5, 3, 4, 1]`

### 第二阶段：排序

**第1轮：提取最大元素10**
```
交换堆顶和末尾：[1, 5, 3, 4, 10]
                            ↑ 已排序区

重新调整堆（大小=4）：
原：  1
     / \
    5   3
   /
  4

调整后：5
       / \
      4   3
     /
    1

结果：[5, 4, 3, 1, 10]
```

**第2轮：提取最大元素5**
```
交换：[1, 4, 3, 5, 10]
              ↑ 已排序区

调整堆（大小=3）：
原：  1
     / \
    4   3

调整后：4
       / \
      1   3

结果：[4, 1, 3, 5, 10]
```

**第3轮：提取最大元素4**
```
交换：[3, 1, 4, 5, 10]
           ↑ 已排序区

调整堆（大小=2）：
原：  3
     /
    1

无需调整：3 > 1

结果：[3, 1, 4, 5, 10]
```

**第4轮：提取最大元素3**
```
交换：[1, 3, 4, 5, 10]
        ↑ 已排序区

只剩一个元素，无需调整
```

**最终结果**：`[1, 3, 4, 5, 10]` ✅

## 可视化过程总结

```
初始数组：[4, 10, 3, 5, 1]

建堆阶段：
[4, 10, 3, 5, 1] → [10, 5, 3, 4, 1]

排序阶段：
[10, 5, 3, 4, 1] → [5, 4, 3, 1, |10]
[5, 4, 3, 1, |10] → [4, 1, 3, |5, 10]
[4, 1, 3, |5, 10] → [3, 1, |4, 5, 10]
[3, 1, |4, 5, 10] → [1, |3, 4, 5, 10]

最终结果：[1, 3, 4, 5, 10]
```

## 复杂度分析

### 时间复杂度
- **建堆阶段**：O(n)
  - 虽然有n/2个节点需要调整，但大部分节点的调整深度很小
  - 数学证明：∑(h=0 to log n) [n/2^(h+1)] × h = O(n)

- **排序阶段**：O(n log n)
  - 需要进行n-1次"提取最大值"操作
  - 每次调整堆的时间复杂度为O(log n)

- **总体时间复杂度**：O(n log n)（所有情况）

### 空间复杂度
- **O(1)**：原地排序，只需要常数级额外空间
- 递归调用栈深度：O(log n)

### 稳定性
- **不稳定**：相同元素的相对位置可能改变
- 例如：[5a, 5b, 3] 可能变成 [3, 5b, 5a]

## 算法特点总结

### 优点 ✅
1. **时间复杂度稳定**：无论最好、平均还是最坏情况都是O(n log n)
2. **空间复杂度优秀**：O(1)原地排序
3. **不受输入数据分布影响**：性能稳定可预测

### 缺点 ❌
1. **不稳定**：相同元素的相对顺序可能改变
2. **常数因子较大**：实际运行时间通常比快速排序慢
3. **缓存不友好**：堆的访问模式对CPU缓存不友好

## 适用场景

### 最佳使用场景 🎯
1. **对时间复杂度要求严格**：不能接受快速排序的O(n²)最坏情况
2. **内存空间受限**：需要原地排序
3. **需要Top-K问题的解决方案**：堆的特性天然适合

### 实际应用
1. **优先队列的实现**
2. **操作系统的任务调度**
3. **图算法中的最短路径**（Dijkstra算法）
4. **大数据处理中的Top-K问题**

## 完整实现

```javascript
/**
 * 堆排序完整实现
 * @param {number[]} arr - 待排序数组
 * @returns {number[]} - 排序后的数组
 */
function heapSort(arr) {
    const result = [...arr]; // 避免修改原数组
    const n = result.length;

    // 第一阶段：建堆
    // 从最后一个非叶子节点开始向上调整
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(result, n, i);
    }

    // 第二阶段：排序
    // 反复提取堆顶最大元素
    for (let i = n - 1; i > 0; i--) {
        // 将堆顶最大元素交换到已排序区域
        [result[0], result[i]] = [result[i], result[0]];

        // 重新调整堆（堆大小减1）
        heapify(result, i, 0);
    }

    return result;
}

/**
 * 堆调整函数（向下调整）
 * @param {number[]} arr - 数组
 * @param {number} heapSize - 堆的大小
 * @param {number} i - 要调整的节点索引
 */
function heapify(arr, heapSize, i) {
    let largest = i;        // 假设当前节点最大
    let left = 2 * i + 1;   // 左子节点索引
    let right = 2 * i + 2;  // 右子节点索引

    // 找到父节点和子节点中的最大值
    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果最大值不是当前节点，则交换并继续调整
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, heapSize, largest);
    }
}

// 测试示例
const testArray = [4, 10, 3, 5, 1, 6, 8, 2, 7, 9];
console.log("原数组：", testArray);
console.log("排序后：", heapSort(testArray));
// 输出：排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

堆排序是一个优雅的算法，它将选择排序的思想与堆数据结构完美结合，在保证O(n log n)时间复杂度的同时实现了原地排序。虽然在实际应用中可能不如快速排序快，但其稳定的性能表现使其在某些场景下仍然是优秀的选择。