# 第11章：排序算法 - 练习题

## 概述
本章练习题精心挑选了5道题目，涵盖排序算法的核心概念和实际应用。从基础的排序实现到复杂的应用场景，帮助巩固排序算法的理解和应用能力。

---

## 练习题1：合并k个排序数组

### 题目描述
给定k个已排序的数组，请将它们合并为一个排序数组。每个数组的长度可能不同，但都是从小到大排序的。

### 核心思想
- **多路归并思想**：类似于归并排序中的合并过程，但需要同时处理多个数组
- **优先队列优化**：使用最小堆来高效地找到下一个最小元素
- **索引管理**：需要维护每个数组的当前位置索引

### 示例
```javascript
输入: [[1,4,5],[1,3,4],[2,6]]
输出: [1,1,2,3,4,4,5,6]

输入: [[1,2,3],[4,5,6],[7,8,9]]
输出: [1,2,3,4,5,6,7,8,9]
```

### 实现要求
1. 实现基础的两两合并方法
2. 实现使用优先队列的高效方法
3. 处理空数组和边界情况
4. 分析时间复杂度和空间复杂度

### 核心知识点
- 归并排序的合并过程
- 多路归并算法
- 优先队列（堆）的应用
- 分治思想的扩展

---

## 练习题2：数组的相对排序

### 题目描述
给定两个数组arr1和arr2，其中arr2中的元素各不相同，arr2中的每个元素都出现在arr1中。
对arr1中的元素进行排序，使得arr1中项的相对顺序和arr2中的相对顺序相同。未在arr2中出现的元素需要按升序放在末尾。

### 核心思想
- **自定义排序规则**：根据arr2的顺序定义新的比较规则
- **映射表优化**：使用哈希表建立元素到优先级的映射
- **稳定排序**：保证相同优先级元素的稳定性

### 示例
```javascript
输入: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出: [2,2,2,1,4,3,3,9,6,7,19]
解释: 按arr2的顺序：2出现3次，1出现1次，4出现1次，3出现2次，9出现1次，6出现1次
     未在arr2中的元素7,19按升序排列
```

### 实现要求
1. 实现基于计数的排序方法
2. 实现基于自定义比较函数的排序
3. 处理重复元素和缺失元素
4. 优化时间和空间复杂度

### 核心知识点
- 计数排序的应用
- 自定义比较函数
- 哈希表的使用
- 排序的稳定性

---

## 练习题3：最大间距问题

### 题目描述
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。如果数组元素个数小于2，则返回0。

### 核心思想
- **桶排序思想**：将元素分配到不同的桶中，最大间距必定出现在桶之间
- **鸽笼原理**：n个元素放入n-1个桶，至少有一个桶为空
- **线性时间复杂度**：要求在O(n)时间内解决，不能使用基于比较的排序

### 示例
```javascript
输入: [3,6,9,1]
输出: 3
解释: 排序后数组为[1,3,6,9]，最大间距为6-3=3

输入: [10]
输出: 0
解释: 只有一个元素，返回0
```

### 实现要求
1. 实现桶排序的解决方案
2. 实现基数排序的解决方案
3. 处理重复元素和特殊情况
4. 确保O(n)时间复杂度

### 核心知识点
- 桶排序算法
- 基数排序算法
- 鸽笼原理的应用
- 线性时间排序算法

---

## 练习题4：会议室安排问题

### 题目描述
给定一个会议时间安排的数组intervals，每个会议时间都会包括开始和结束的时间intervals[i] = [starti, endi]，
请你判断一个人是否能够参加这里面的全部会议。如果可以，返回安排的会议顺序；如果不可以，返回最少需要几个会议室。

### 核心思想
- **区间排序**：按照会议开始时间或结束时间进行排序
- **贪心算法**：选择最优的会议安排策略
- **优先队列**：动态维护会议室的结束时间

### 示例
```javascript
输入: [[0,30],[5,10],[15,20]]
输出: false, 需要2个会议室
解释: 会议[0,30]和[5,10]时间重叠

输入: [[7,10],[2,4]]
输出: true, 安排顺序为[[2,4],[7,10]]
```

### 实现要求
1. 实现判断是否可以参加所有会议
2. 实现计算最少需要的会议室数量
3. 实现最优会议安排顺序
4. 处理边界情况和特殊输入

### 核心知识点
- 区间调度问题
- 贪心算法思想
- 排序在优化问题中的应用
- 优先队列的使用

---

## 练习题5：自定义排序器设计

### 题目描述
设计一个通用的排序器类，支持多种排序算法和自定义比较函数。要求能够：
1. 根据数据特征自动选择最适合的排序算法
2. 支持多关键字排序
3. 提供性能统计功能
4. 支持稳定排序和非稳定排序的选择

### 核心思想
- **策略模式**：封装不同的排序算法，可以动态切换
- **数据分析**：分析输入数据的特征来选择最优算法
- **性能监控**：记录排序过程中的关键指标

### 示例
```javascript
const sorter = new CustomSorter();

// 自动选择算法
const result1 = sorter.autoSort([3,1,4,1,5,9,2,6]);

// 多关键字排序
const students = [
    {name: "Alice", grade: 85, age: 20},
    {name: "Bob", grade: 85, age: 19},
    {name: "Charlie", grade: 90, age: 20}
];
const result2 = sorter.multiKeySort(students, [
    {key: 'grade', order: 'desc'},
    {key: 'age', order: 'asc'},
    {key: 'name', order: 'asc'}
]);

// 性能统计
const stats = sorter.getPerformanceStats();
```

### 实现要求
1. 实现多种排序算法的封装
2. 实现数据特征分析功能
3. 实现多关键字排序支持
4. 实现性能统计和监控
5. 提供友好的API接口

### 核心知识点
- 设计模式的应用
- 排序算法的选择策略
- 性能分析和优化
- 面向对象编程

---

## 难度分布

| 题目 | 难度 | 主要考查点 |
|------|------|------------|
| 练习题1 | 中等 | 多路归并、优先队列 |
| 练习题2 | 中等 | 自定义排序、计数排序 |
| 练习题3 | 困难 | 桶排序、线性时间算法 |
| 练习题4 | 中等 | 贪心算法、区间调度 |
| 练习题5 | 困难 | 系统设计、算法选择 |

## 核心知识点总结

### 排序算法分类
1. **比较排序**：冒泡、选择、插入、归并、快排、堆排序
2. **非比较排序**：计数、桶、基数排序
3. **混合排序**：Tim排序、内省排序

### 算法选择策略
1. **数据规模**：小数据用简单排序，大数据用高效排序
2. **数据特征**：有序度、重复度、数据类型
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否允许使用额外空间

### 实际应用场景
1. **数据库排序**：多关键字排序、外部排序
2. **系统调度**：任务优先级排序、资源分配
3. **数据分析**：TOP-K问题、分位数计算
4. **图形算法**：事件排序、扫描线算法

### 解题思路模板

#### 1. 分析问题特征
```
- 数据规模和类型
- 是否需要稳定排序
- 时间和空间复杂度要求
- 是否有特殊的排序规则
```

#### 2. 选择合适算法
```
- 小规模数据：插入排序、选择排序
- 大规模数据：归并排序、快速排序
- 特殊数据：计数排序、桶排序、基数排序
- 自定义规则：自定义比较函数
```

#### 3. 实现和优化
```
- 处理边界情况
- 优化常数因子
- 考虑缓存友好性
- 添加性能监控
```

这些练习题涵盖了排序算法的核心概念和实际应用，通过练习可以深入理解不同排序算法的特点和适用场景，提高解决实际问题的能力。 