# æœ€å¤§äºŒå‰æ ‘é—®é¢˜ ğŸŒŸ

## ğŸ¯ é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ `nums`ï¼Œæœ€å¤§äºŒå‰æ ‘å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» `nums` é€’å½’åœ°æ„å»ºï¼š

1. åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º `nums` ä¸­çš„æœ€å¤§å€¼ã€‚
2. é€’å½’åœ°åœ¨æœ€å¤§å€¼ **å·¦è¾¹** çš„ **å­æ•°ç»„å‰ç¼€** ä¸Šæ„å»ºå·¦å­æ ‘ã€‚
3. é€’å½’åœ°åœ¨æœ€å¤§å€¼ **å³è¾¹** çš„ **å­æ•°ç»„åç¼€** ä¸Šæ„å»ºå³å­æ ‘ã€‚

è¿”å› `nums` æ„å»ºçš„ **æœ€å¤§äºŒå‰æ ‘**ã€‚

**è¦æ±‚**ï¼š
- æ•°ç»„ `nums` ä¸­çš„æ‰€æœ‰å€¼éƒ½æ˜¯å”¯ä¸€çš„
- 1 <= nums.length <= 1000
- 1 <= nums[i] <= 1000

**ç¤ºä¾‹**ï¼š
```javascript
// ç¤ºä¾‹ 1
è¾“å…¥: nums = [3,2,1,6,0,5]
è¾“å‡º: [6,3,5,null,2,0,null,null,1]
è§£é‡Š:
     6
   â”Œâ”€â”´â”€â”
   3   5
   â””â” â”Œâ”˜
    2 0
    â””â”
     1

// ç¤ºä¾‹ 2
è¾“å…¥: nums = [3,2,1]
è¾“å‡º: [3,null,2,null,1]

// ç¤ºä¾‹ 3
è¾“å…¥: nums = [1]
è¾“å‡º: [1]

// ç¤ºä¾‹ 4
è¾“å…¥: nums = [1,2,3,4]
è¾“å‡º: [4,1,null,null,3,null,2]
```

## ğŸ’¡ æˆ‘çš„åŸå§‹æ–¹æ³•

### æ€è·¯åˆ†æ
ç”¨æˆ·çš„åŸå§‹æƒ³æ³•æ˜¯ï¼š
1. æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹
2. å°†æ•°ç»„åˆ†ä¸ºå·¦å³ä¸¤éƒ¨åˆ†ï¼šæœ€å¤§å€¼å·¦è¾¹å’Œå³è¾¹çš„å­æ•°ç»„
3. é€’å½’åœ°å¯¹å·¦å³å­æ•°ç»„è¿›è¡ŒåŒæ ·çš„æ“ä½œ
4. æ„å»ºTreeNodeå¹¶è¿”å›

### åŸå§‹ä»£ç 
```javascript
function TreeNode(val, left, right) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
}

var constructMaximumBinaryTree = function (nums) {
    let max = Math.max(...nums);
    maxPosition = nums.indexOf(max);

    let left = nums.slice(0, maxPosition);
    let right = nums.slice(maxPosition + 1);
    console.log(right, "right");
    let leftNodeVal, rightNodeVal;

    if (left.length) {
        leftNodeVal = constructMaximumBinaryTree(left);
    } else {
        leftNodeVal = null;
    }

    if (right.length) {
        rightNodeVal = constructMaximumBinaryTree(right);
    } else {
        rightNodeVal = null;
    }

    let node = new TreeNode(max, leftNodeVal, rightNodeVal);
    console.log(node);
    return node;
};

// BFSéå†ï¼ˆç”¨æˆ·çš„ç‰ˆæœ¬ï¼‰
const BFS = (node) => {
    let root = [node];
    while (root.length) {
        let child = root.shift();
        console.log(child.val);

        if (child.left) {
            root.push(child.left);
        }
        if (child.right) {
            root.push(child.right);
        }
    }
};
```

### ç®—æ³•ä¼˜ç‚¹
- âœ… **æ ¸å¿ƒæ€æƒ³æ­£ç¡®**ï¼šæ­£ç¡®ç†è§£äº†æœ€å¤§äºŒå‰æ ‘çš„æ„å»ºé€»è¾‘
- âœ… **é€’å½’ç»“æ„æ¸…æ™°**ï¼šé€’å½’çš„ç»ˆæ­¢æ¡ä»¶å’Œé€’å½’è°ƒç”¨éƒ½å¾ˆåˆç†
- âœ… **è¾¹ç•Œå¤„ç†å¾—å½“**ï¼šæ­£ç¡®å¤„ç†äº†ç©ºæ•°ç»„çš„æƒ…å†µ
- âœ… **ä»£ç é€»è¾‘å®Œæ•´**ï¼šèƒ½å¤Ÿæ­£ç¡®æ„å»ºå‡ºæœ€å¤§äºŒå‰æ ‘

### å­˜åœ¨çš„é—®é¢˜
- âŒ **BFSéå†ä¸å®Œæ•´**ï¼šæ— æ³•æ˜¾ç¤ºnullèŠ‚ç‚¹ï¼Œçœ‹ä¸åˆ°å®Œæ•´çš„æ ‘ç»“æ„
- âŒ **å˜é‡å£°æ˜é—®é¢˜**ï¼š`maxPosition`æ²¡æœ‰ç”¨`let`æˆ–`var`å£°æ˜
- âŒ **æ€§èƒ½å¯ä¼˜åŒ–**ï¼šæ¯æ¬¡éƒ½ç”¨`Math.max`å’Œ`indexOf`æŸ¥æ‰¾æœ€å¤§å€¼
- âŒ **ç¼ºå°‘æ³¨é‡Š**ï¼šæ ¸å¿ƒç®—æ³•æ­¥éª¤ç¼ºå°‘è¯¦ç»†æ³¨é‡Š

## ğŸ”§ æ”¹è¿›ç‰ˆæœ¬

### ä¼˜åŒ–æ€è·¯
1. **ä¿®å¤BFSéå†**ï¼šè®©BFSèƒ½å¤Ÿæ˜¾ç¤ºnullèŠ‚ç‚¹ï¼Œå±•ç¤ºå®Œæ•´çš„æ ‘ç»“æ„
2. **å˜é‡å£°æ˜è§„èŒƒ**ï¼šä¿®å¤å˜é‡å£°æ˜é—®é¢˜
3. **æ·»åŠ è¯¦ç»†æ³¨é‡Š**ï¼šè¯´æ˜ç®—æ³•çš„æ ¸å¿ƒæ€æƒ³å’Œæ¯ä¸ªæ­¥éª¤
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šæä¾›ä¸€æ¬¡éå†æ‰¾æœ€å¤§å€¼çš„ä¼˜åŒ–ç‰ˆæœ¬

### æ”¹è¿›ä»£ç 
```javascript
/**
 * äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰
 */
function TreeNode(val, left, right) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
}

/**
 * æ„å»ºæœ€å¤§äºŒå‰æ ‘ï¼ˆæ”¹è¿›ç‰ˆï¼‰
 *
 * æ ¸å¿ƒæ€æƒ³ï¼š
 * é‡‡ç”¨åˆ†æ²»çš„æ€æƒ³ï¼Œé€’å½’åœ°æ„å»ºäºŒå‰æ ‘ï¼š
 * 1. æ‰¾åˆ°å½“å‰æ•°ç»„çš„æœ€å¤§å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹
 * 2. æœ€å¤§å€¼å·¦è¾¹çš„å­æ•°ç»„æ„å»ºå·¦å­æ ‘
 * 3. æœ€å¤§å€¼å³è¾¹çš„å­æ•°ç»„æ„å»ºå³å­æ ‘
 * 4. é€’å½’å¤„ç†ç›´åˆ°å­æ•°ç»„ä¸ºç©º
 *
 * @param {number[]} nums - è¾“å…¥æ•°ç»„
 * @returns {TreeNode} æ„å»ºçš„æœ€å¤§äºŒå‰æ ‘æ ¹èŠ‚ç‚¹
 * @time O(nÂ²) æœ€åæƒ…å†µï¼ŒO(n log n) å¹³å‡æƒ…å†µ
 * @space O(n) é€’å½’æ ˆç©ºé—´
 */
var constructMaximumBinaryTree = function (nums) {
    // è¾¹ç•Œæ¡ä»¶ï¼šç©ºæ•°ç»„è¿”å›null
    if (!nums || nums.length === 0) {
        return null;
    }

    // æ‰¾åˆ°æœ€å¤§å€¼å’Œå…¶ä½ç½®
    let max = Math.max(...nums);
    let maxPosition = nums.indexOf(max);  // ä¿®å¤ï¼šæ·»åŠ å˜é‡å£°æ˜

    // åˆ†å‰²æ•°ç»„ï¼šæœ€å¤§å€¼å·¦è¾¹å’Œå³è¾¹çš„å­æ•°ç»„
    let leftArray = nums.slice(0, maxPosition);
    let rightArray = nums.slice(maxPosition + 1);

    console.log(`å¤„ç†æ•°ç»„: [${nums.join(',')}]`);
    console.log(`æœ€å¤§å€¼: ${max}, ä½ç½®: ${maxPosition}`);
    console.log(`å·¦å­æ•°ç»„: [${leftArray.join(',')}], å³å­æ•°ç»„: [${rightArray.join(',')}]`);

    // é€’å½’æ„å»ºå·¦å³å­æ ‘
    let leftNode = constructMaximumBinaryTree(leftArray);
    let rightNode = constructMaximumBinaryTree(rightArray);

    // åˆ›å»ºå½“å‰èŠ‚ç‚¹
    let node = new TreeNode(max, leftNode, rightNode);

    console.log(`åˆ›å»ºèŠ‚ç‚¹: ${max}, å·¦å­æ ‘: ${leftNode?.val || 'null'}, å³å­æ ‘: ${rightNode?.val || 'null'}`);

    return node;
};

/**
 * BFSå±‚åºéå†ï¼ˆæ˜¾ç¤ºå®Œæ•´ç»“æ„ç‰ˆæœ¬ï¼‰
 *
 * æ ¸å¿ƒæ”¹è¿›ï¼š
 * 1. ä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹å’Œå…¶å¯¹åº”çš„ä½ç½®ä¿¡æ¯
 * 2. æ˜¾ç¤ºnullèŠ‚ç‚¹ä»¥å±•ç¤ºå®Œæ•´çš„æ ‘ç»“æ„
 * 3. æŒ‰å±‚çº§æ ¼å¼åŒ–è¾“å‡ºï¼Œä¾¿äºç†è§£æ ‘çš„ç»“æ„
 *
 * @param {TreeNode} root - äºŒå‰æ ‘æ ¹èŠ‚ç‚¹
 */
const BFS_Complete = (root) => {
    if (!root) {
        console.log("ç©ºæ ‘");
        return;
    }

    console.log("\n=== å®Œæ•´BFSéå†ï¼ˆåŒ…å«nullèŠ‚ç‚¹ï¼‰===");
    let queue = [root];
    let level = 0;
    let result = [];

    while (queue.length > 0) {
        let levelSize = queue.length;
        let currentLevel = [];
        let hasNonNull = false;

        console.log(`\nç¬¬${level}å±‚:`);

        for (let i = 0; i < levelSize; i++) {
            let node = queue.shift();

            if (node === null) {
                currentLevel.push('null');
                console.log(`  ä½ç½®${i}: null`);
                // nullèŠ‚ç‚¹ä¹Ÿè¦ä¸ºä¸‹ä¸€å±‚æ·»åŠ å ä½ç¬¦ï¼ˆå¦‚æœè¿˜æœ‰å±‚çº§çš„è¯ï¼‰
                queue.push(null, null);
            } else {
                currentLevel.push(node.val);
                console.log(`  ä½ç½®${i}: ${node.val}`);
                hasNonNull = true;

                // æ·»åŠ å·¦å³å­èŠ‚ç‚¹ï¼ˆå³ä½¿æ˜¯nullä¹Ÿè¦æ·»åŠ ï¼‰
                queue.push(node.left, node.right);
            }
        }

        result.push(currentLevel);
        level++;

        // å¦‚æœä¸‹ä¸€å±‚æ²¡æœ‰énullèŠ‚ç‚¹ï¼Œåœæ­¢éå†
        if (!hasNonNull) {
            break;
        }
    }

    console.log("\nå±‚åºéå†ç»“æœæ•°ç»„:", result);
    console.log("LeetCodeæ ¼å¼è¾“å‡º:", result.flat().filter((val, index, arr) => {
        // ç§»é™¤æœ«å°¾çš„è¿ç»­null
        let lastNonNullIndex = arr.length - 1;
        while (lastNonNullIndex >= 0 && arr[lastNonNullIndex] === 'null') {
            lastNonNullIndex--;
        }
        return index <= lastNonNullIndex;
    }));
};

/**
 * BFSå±‚åºéå†ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
 * è§£å†³ç”¨æˆ·åŸå§‹é—®é¢˜ï¼šæ˜¾ç¤ºnullèŠ‚ç‚¹
 */
const BFS_Fixed = (node) => {
    if (!node) return;

    console.log("\n=== ä¿®å¤åçš„BFSéå† ===");
    let queue = [node];

    while (queue.length > 0) {
        let current = queue.shift();

        // æ‰“å°å½“å‰èŠ‚ç‚¹å€¼ï¼ˆåŒ…æ‹¬nullï¼‰
        if (current === null) {
            console.log('null');
        } else {
            console.log(current.val);
            // æ·»åŠ å­èŠ‚ç‚¹åˆ°é˜Ÿåˆ—ï¼ˆå³ä½¿æ˜¯nullä¹Ÿæ·»åŠ ï¼‰
            queue.push(current.left);
            queue.push(current.right);
        }

        // é¿å…æ— é™å¾ªç¯ï¼šå¦‚æœé˜Ÿåˆ—ä¸­éƒ½æ˜¯nullï¼Œåœæ­¢
        if (queue.every(item => item === null)) {
            break;
        }
    }
};

// å®Œæ•´æµ‹è¯•å‡½æ•°
function testMaximumBinaryTree() {
    const testCases = [
        {
            input: [3, 2, 1, 6, 0, 5],
            description: "æ ‡å‡†æµ‹è¯•ç”¨ä¾‹"
        },
        {
            input: [3, 2, 1],
            description: "é€’å‡åºåˆ—"
        },
        {
            input: [1, 2, 3, 4],
            description: "é€’å¢åºåˆ—"
        },
        {
            input: [1],
            description: "å•ä¸ªå…ƒç´ "
        }
    ];

    testCases.forEach((testCase, index) => {
        console.log(`\nğŸ§ª æµ‹è¯•ç”¨ä¾‹ ${index + 1}: ${testCase.description}`);
        console.log(`è¾“å…¥: [${testCase.input.join(', ')}]`);
        console.log("==========================================");

        let tree = constructMaximumBinaryTree(testCase.input);

        console.log("\nğŸŒ³ æ„å»ºå®Œæˆçš„æ ‘ç»“æ„:");
        BFS_Complete(tree);

        console.log("\nğŸ“Š ç®€åŒ–BFSéå†:");
        BFS_Fixed(tree);

        console.log("\n" + "=".repeat(50));
    });
}
```

### æ”¹è¿›äº®ç‚¹
- âœ… **BFSæ˜¾ç¤ºå®Œæ•´ç»“æ„**ï¼šèƒ½å¤Ÿæ˜¾ç¤ºnullèŠ‚ç‚¹ï¼Œå±•ç¤ºå®Œæ•´çš„æ ‘å½¢ç»“æ„
- âœ… **å±‚çº§åŒ–è¾“å‡º**ï¼šæŒ‰å±‚æ˜¾ç¤ºèŠ‚ç‚¹ï¼Œä¾¿äºç†è§£æ ‘çš„ç»“æ„
- âœ… **LeetCodeæ ¼å¼**ï¼šè¾“å‡ºç¬¦åˆLeetCodeæ ‡å‡†çš„æ•°ç»„æ ¼å¼
- âœ… **è¯¦ç»†è°ƒè¯•ä¿¡æ¯**ï¼šæ¯æ­¥æ„å»ºè¿‡ç¨‹éƒ½æœ‰æ¸…æ™°çš„è¾“å‡º

## ğŸŒŸ æ¨èçš„æœ€ä½³æ–¹æ³•

### æ–¹æ³•ä¸€ï¼šä¼˜åŒ–çš„åˆ†æ²»æ„å»ºï¼ˆé¢è¯•æ¨èï¼‰
```javascript
/**
 * æœ€å¤§äºŒå‰æ ‘æ„å»º - ä¼˜åŒ–ç‰ˆæœ¬
 *
 * æ ¸å¿ƒæ€æƒ³ï¼šä½¿ç”¨åŒºé—´ç´¢å¼•é¿å…æ•°ç»„åˆ‡ç‰‡ï¼Œæå‡æ€§èƒ½
 *
 * @param {number[]} nums - åŸæ•°ç»„
 * @param {number} left - å·¦è¾¹ç•Œ
 * @param {number} right - å³è¾¹ç•Œ
 * @returns {TreeNode} æ ‘èŠ‚ç‚¹
 * @time O(nÂ²) æœ€åæƒ…å†µï¼ŒO(n log n) å¹³å‡æƒ…å†µ
 * @space O(n) é€’å½’æ ˆç©ºé—´
 */
var constructMaximumBinaryTreeOptimized = function(nums, left = 0, right = nums.length - 1) {
    if (left > right) {
        return null;
    }

    // æ‰¾åˆ°åŒºé—´å†…çš„æœ€å¤§å€¼ç´¢å¼•
    let maxIndex = left;
    for (let i = left + 1; i <= right; i++) {
        if (nums[i] > nums[maxIndex]) {
            maxIndex = i;
        }
    }

    // æ„å»ºèŠ‚ç‚¹
    let root = new TreeNode(nums[maxIndex]);
    root.left = constructMaximumBinaryTreeOptimized(nums, left, maxIndex - 1);
    root.right = constructMaximumBinaryTreeOptimized(nums, maxIndex + 1, right);

    return root;
};
```

### æ–¹æ³•äºŒï¼šå•è°ƒæ ˆè§£æ³•ï¼ˆé«˜çº§ä¼˜åŒ–ï¼‰
```javascript
/**
 * å•è°ƒæ ˆæ„å»ºæœ€å¤§äºŒå‰æ ‘
 *
 * æ ¸å¿ƒæ€æƒ³ï¼š
 * ä½¿ç”¨å•è°ƒé€’å‡æ ˆï¼Œç»´æŠ¤ä»æ ¹åˆ°å½“å‰èŠ‚ç‚¹è·¯å¾„ä¸Šçš„æœ€å¤§å€¼åºåˆ—
 * æ—¶é—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ°O(n)
 *
 * @param {number[]} nums - è¾“å…¥æ•°ç»„
 * @returns {TreeNode} æ ‘æ ¹èŠ‚ç‚¹
 * @time O(n) æ¯ä¸ªå…ƒç´ æœ€å¤šå…¥æ ˆå‡ºæ ˆä¸€æ¬¡
 * @space O(n) æ ˆç©ºé—´
 */
var constructMaximumBinaryTreeStack = function(nums) {
    let stack = [];

    for (let num of nums) {
        let node = new TreeNode(num);
        let lastPopped = null;

        // å¼¹å‡ºæ‰€æœ‰æ¯”å½“å‰å€¼å°çš„èŠ‚ç‚¹
        while (stack.length > 0 && stack[stack.length - 1].val < num) {
            lastPopped = stack.pop();
        }

        // æœ€åå¼¹å‡ºçš„èŠ‚ç‚¹æˆä¸ºå½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘
        if (lastPopped) {
            node.left = lastPopped;
        }

        // å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå½“å‰èŠ‚ç‚¹æˆä¸ºæ ˆé¡¶çš„å³å­æ ‘
        if (stack.length > 0) {
            stack[stack.length - 1].right = node;
        }

        stack.push(node);
    }

    return stack[0]; // æ ˆåº•æ˜¯æ ¹èŠ‚ç‚¹
};
```

### æ–¹æ³•ä¸‰ï¼šåŸºäºåŸå§‹æ€è·¯çš„ä¼˜åŒ–
```javascript
/**
 * æœ€å¤§äºŒå‰æ ‘æ„å»º - åŸºäºç”¨æˆ·åŸå§‹æ€è·¯çš„æŠ€æœ¯ä¼˜åŒ–
 *
 * @param {number[]} nums - è¾“å…¥æ•°ç»„
 * @returns {TreeNode} æ ‘æ ¹èŠ‚ç‚¹
 * @time O(nÂ²) æ—¶é—´å¤æ‚åº¦
 * @space O(n) ç©ºé—´å¤æ‚åº¦
 */
var constructMaximumBinaryTreeImproved = function(nums) {
    if (!nums || nums.length === 0) return null;

    // ä¸€æ¬¡éå†æ‰¾åˆ°æœ€å¤§å€¼å’Œä½ç½®ï¼ˆé¿å…ä¸¤æ¬¡éå†ï¼‰
    let max = nums[0];
    let maxPosition = 0;

    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
            maxPosition = i;
        }
    }

    // ä½¿ç”¨ç´¢å¼•è€Œéæ•°ç»„åˆ‡ç‰‡ï¼ˆå‡å°‘å†…å­˜åˆ†é…ï¼‰
    let leftArray = nums.slice(0, maxPosition);
    let rightArray = nums.slice(maxPosition + 1);

    // é€’å½’æ„å»º
    let leftNode = leftArray.length > 0 ? constructMaximumBinaryTreeImproved(leftArray) : null;
    let rightNode = rightArray.length > 0 ? constructMaximumBinaryTreeImproved(rightArray) : null;

    return new TreeNode(max, leftNode, rightNode);
};
```

### æ–¹æ³•å››ï¼šå®Œæ•´çš„BFSéå†å·¥å…·é›†
```javascript
/**
 * äºŒå‰æ ‘å¯è§†åŒ–å·¥å…·é›†
 */
class BinaryTreeVisualizer {
    /**
     * å±‚åºéå†ï¼ˆåŒ…å«nullèŠ‚ç‚¹ï¼‰
     */
    static levelOrderWithNull(root) {
        if (!root) return ['null'];

        let result = [];
        let queue = [root];

        while (queue.length > 0) {
            let node = queue.shift();

            if (node === null) {
                result.push('null');
            } else {
                result.push(node.val);
                queue.push(node.left);
                queue.push(node.right);
            }

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰énullèŠ‚ç‚¹
            if (queue.every(n => n === null)) break;
        }

        // ç§»é™¤æœ«å°¾çš„null
        while (result[result.length - 1] === 'null') {
            result.pop();
        }

        return result;
    }

    /**
     * ç¾åŒ–çš„å±‚çº§æ˜¾ç¤º
     */
    static prettyPrint(root) {
        if (!root) {
            console.log("ç©ºæ ‘");
            return;
        }

        let queue = [{node: root, level: 0, pos: 0}];
        let levels = [];

        while (queue.length > 0) {
            let {node, level, pos} = queue.shift();

            if (!levels[level]) levels[level] = [];
            levels[level].push({val: node ? node.val : 'null', pos});

            if (node) {
                queue.push({node: node.left, level: level + 1, pos: pos * 2});
                queue.push({node: node.right, level: level + 1, pos: pos * 2 + 1});
            }
        }

        levels.forEach((level, i) => {
            console.log(`ç¬¬${i}å±‚:`, level.map(n => n.val).join('  '));
        });
    }

    /**
     * ASCIIè‰ºæœ¯æ ‘å½¢æ˜¾ç¤º
     */
    static drawTree(root) {
        if (!root) return;

        function getHeight(node) {
            if (!node) return 0;
            return 1 + Math.max(getHeight(node.left), getHeight(node.right));
        }

        function printLevel(node, level, currentLevel, spacing) {
            if (!node || currentLevel > level) return '';
            if (currentLevel === level) {
                return ' '.repeat(spacing) + node.val + ' '.repeat(spacing);
            }

            let left = printLevel(node.left, level, currentLevel + 1, spacing / 2);
            let right = printLevel(node.right, level, currentLevel + 1, spacing / 2);
            return left + right;
        }

        let height = getHeight(root);
        for (let i = 0; i < height; i++) {
            console.log(printLevel(root, i, 0, Math.pow(2, height - i - 1)));
        }
    }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|------|------|----------|
| åŸå§‹æ–¹æ³• | O(nÂ²) | O(nÂ²) | æ€è·¯æ¸…æ™°æ˜“æ‡‚ | å†…å­˜ä½¿ç”¨å¤šï¼ŒBFSä¸å®Œæ•´ | å­¦ä¹ ç†è§£ |
| æ”¹è¿›æ–¹æ³• | O(nÂ²) | O(n) | ä¿®å¤BFSï¼Œå‡å°‘å†…å­˜ | æ—¶é—´å¤æ‚åº¦æœªä¼˜åŒ– | é¢è¯•å±•ç¤º |
| åŒºé—´ä¼˜åŒ– | O(nÂ²) | O(n) | é¿å…æ•°ç»„åˆ‡ç‰‡ | æœ€åæƒ…å†µä»æ˜¯O(nÂ²) | ä»£ç ä¼˜åŒ– |
| å•è°ƒæ ˆ | O(n) | O(n) | æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ | ç†è§£éš¾åº¦è¾ƒå¤§ | é«˜çº§ä¼˜åŒ– |
| å¯è§†åŒ–å·¥å…· | O(n) | O(n) | åŠŸèƒ½å®Œæ•´ç¾è§‚ | ä»£ç é‡è¾ƒå¤§ | è°ƒè¯•è¾…åŠ© |

## ğŸ“ çŸ¥è¯†ç‚¹æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ
1. **åˆ†æ²»ç®—æ³•**ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºæ›´å°çš„å­é—®é¢˜é€’å½’è§£å†³
2. **äºŒå‰æ ‘æ„å»º**ï¼šæ ¹æ®è§„åˆ™é€’å½’æ„å»ºæ ‘ç»“æ„çš„æ–¹æ³•
3. **å±‚åºéå†**ï¼šä½¿ç”¨é˜Ÿåˆ—è¿›è¡ŒBFSéå†äºŒå‰æ ‘
4. **å•è°ƒæ ˆ**ï¼šç»´æŠ¤å•è°ƒæ€§è´¨çš„æ ˆç»“æ„ï¼Œç”¨äºä¼˜åŒ–ç®—æ³•

### å…³é”®æŠ€å·§
- **BFSæ˜¾ç¤ºnullèŠ‚ç‚¹**ï¼šåœ¨é˜Ÿåˆ—ä¸­ä¿ç•™nullæŒ‡é’ˆä»¥æ˜¾ç¤ºå®Œæ•´ç»“æ„
- **åŒºé—´ç´¢å¼•ä¼˜åŒ–**ï¼šä½¿ç”¨ç´¢å¼•è€Œéæ•°ç»„åˆ‡ç‰‡å‡å°‘å†…å­˜åˆ†é…
- **å•è°ƒæ ˆæ„å»º**ï¼šåˆ©ç”¨æ ˆçš„æ€§è´¨åœ¨çº¿æ€§æ—¶é—´å†…æ„å»ºæ ‘
- **å¯è§†åŒ–è¾…åŠ©**ï¼šä½¿ç”¨å¤šç§æ–¹å¼å±•ç¤ºæ ‘ç»“æ„å¸®åŠ©ç†è§£

### å®é™…åº”ç”¨
1. **è¡¨è¾¾å¼æ ‘æ„å»º**ï¼šæ ¹æ®ä¼˜å…ˆçº§æ„å»ºè¡¨è¾¾å¼è§£ææ ‘
2. **Huffmanç¼–ç æ ‘**ï¼šæ„å»ºæœ€ä¼˜äºŒè¿›åˆ¶ç¼–ç æ ‘
3. **å†³ç­–æ ‘ç®—æ³•**ï¼šæœºå™¨å­¦ä¹ ä¸­çš„å†³ç­–æ ‘æ„å»º
4. **è¯­æ³•åˆ†ææ ‘**ï¼šç¼–è¯‘å™¨ä¸­çš„è¯­æ³•æ ‘æ„å»º

## ğŸš¨ å¸¸è§é™·é˜±

### é™·é˜±1ï¼šBFSéå†ä¸æ˜¾ç¤ºnullèŠ‚ç‚¹
```javascript
// âŒ é”™è¯¯ï¼šæ— æ³•çœ‹åˆ°å®Œæ•´æ ‘ç»“æ„
const BFS_Wrong = (node) => {
    let queue = [node];
    while (queue.length) {
        let current = queue.shift();
        console.log(current.val); // åªæ˜¾ç¤ºæœ‰å€¼çš„èŠ‚ç‚¹

        if (current.left) queue.push(current.left);
        if (current.right) queue.push(current.right);
    }
};

// âœ… æ­£ç¡®ï¼šæ˜¾ç¤ºåŒ…æ‹¬nullåœ¨å†…çš„å®Œæ•´ç»“æ„
const BFS_Correct = (node) => {
    let queue = [node];
    while (queue.length) {
        let current = queue.shift();
        console.log(current ? current.val : 'null');

        if (current) {
            queue.push(current.left);  // å³ä½¿æ˜¯nullä¹Ÿè¦å…¥é˜Ÿ
            queue.push(current.right);
        }

        // é˜²æ­¢æ— é™å¾ªç¯
        if (queue.every(n => n === null)) break;
    }
};
```

### é™·é˜±2ï¼šå˜é‡å£°æ˜é—æ¼
```javascript
// âŒ é”™è¯¯ï¼šå…¨å±€å˜é‡æ±¡æŸ“
let max = Math.max(...nums);
maxPosition = nums.indexOf(max); // å¿˜è®°å£°æ˜

// âœ… æ­£ç¡®ï¼šæ˜ç¡®å£°æ˜å˜é‡
let max = Math.max(...nums);
let maxPosition = nums.indexOf(max);
```

### é™·é˜±3ï¼šæ•°ç»„è¾¹ç•Œå¤„ç†
```javascript
// âŒ é”™è¯¯ï¼šæ²¡æœ‰æ£€æŸ¥ç©ºæ•°ç»„
let leftArray = nums.slice(0, maxPosition);
let leftNode = constructMaximumBinaryTree(leftArray); // å¯èƒ½ä¼ å…¥ç©ºæ•°ç»„

// âœ… æ­£ç¡®ï¼šæ£€æŸ¥æ•°ç»„é•¿åº¦
let leftArray = nums.slice(0, maxPosition);
let leftNode = leftArray.length > 0 ? constructMaximumBinaryTree(leftArray) : null;
```

## ğŸ’­ å­¦ä¹ å¿ƒå¾—

### å¯¹ä½ çš„ç®—æ³•è¯„ä»·
1. **æ ¸å¿ƒæ€è·¯ä¼˜ç§€** âœ…ï¼šå®Œå…¨ç†è§£äº†æœ€å¤§äºŒå‰æ ‘çš„æ„å»ºè§„åˆ™å’Œåˆ†æ²»æ€æƒ³
2. **é€’å½’é€»è¾‘æ¸…æ™°** âœ…ï¼šæ­£ç¡®å®ç°äº†é€’å½’çš„ç»ˆæ­¢æ¡ä»¶å’Œé€’å½’è°ƒç”¨
3. **è¾¹ç•Œå¤„ç†å®Œå–„** âœ…ï¼šå¦¥å–„å¤„ç†äº†ç©ºæ•°ç»„å’Œå¶å­èŠ‚ç‚¹çš„æƒ…å†µ
4. **BFSéå†å¾…å®Œå–„** ğŸ”„ï¼šåŸç‰ˆæœ¬æ— æ³•æ˜¾ç¤ºnullèŠ‚ç‚¹ï¼Œéœ€è¦æ”¹è¿›

### ä¼˜åŒ–å»ºè®®
1. **å®Œå–„BFSéå†**ï¼šæ·»åŠ nullèŠ‚ç‚¹æ˜¾ç¤ºï¼Œå±•ç¤ºå®Œæ•´æ ‘ç»“æ„
2. **å˜é‡å£°æ˜è§„èŒƒ**ï¼šä½¿ç”¨let/constå£°æ˜æ‰€æœ‰å˜é‡
3. **æ€§èƒ½ä¼˜åŒ–è€ƒè™‘**ï¼šå¯ä»¥å°è¯•å•è°ƒæ ˆç­‰é«˜çº§è§£æ³•
4. **ä»£ç æ³¨é‡Šå¢å¼º**ï¼šæ·»åŠ ç®—æ³•æ€æƒ³å’Œå…³é”®æ­¥éª¤çš„è¯´æ˜

### è§£é¢˜æ¨¡æ¿
```javascript
function constructMaximumBinaryTree(nums) {
    // 1. è¾¹ç•Œæ£€æŸ¥
    if (!nums || nums.length === 0) return null;

    // 2. æ‰¾æœ€å¤§å€¼å’Œä½ç½®
    let max = Math.max(...nums);
    let maxPos = nums.indexOf(max);

    // 3. åˆ†å‰²æ•°ç»„
    let left = nums.slice(0, maxPos);
    let right = nums.slice(maxPos + 1);

    // 4. é€’å½’æ„å»º
    let root = new TreeNode(max);
    root.left = left.length > 0 ? constructMaximumBinaryTree(left) : null;
    root.right = right.length > 0 ? constructMaximumBinaryTree(right) : null;

    return root;
}
```

### é¢è¯•è¦ç‚¹
- ğŸ¯ **åˆ†æ²»æ€æƒ³**ï¼šå¼ºè°ƒç®—æ³•çš„åˆ†æ²»æœ¬è´¨å’Œé€’å½’ç»“æ„
- ğŸ¯ **æ—¶é—´å¤æ‚åº¦**ï¼šèƒ½åˆ†æO(nÂ²)çš„æœ€åæƒ…å†µå’Œä¼˜åŒ–æ–¹æ¡ˆ
- ğŸ¯ **ç©ºé—´ä¼˜åŒ–**ï¼šæåˆ°åŒºé—´ç´¢å¼•é¿å…æ•°ç»„åˆ‡ç‰‡çš„ä¼˜åŒ–
- ğŸ¯ **é«˜çº§è§£æ³•**ï¼šäº†è§£å•è°ƒæ ˆO(n)è§£æ³•çš„å­˜åœ¨

### å®é™…åº”ç”¨åœºæ™¯
- ğŸ”§ **ç¼–è¯‘å™¨è®¾è®¡**ï¼šæ„å»ºæŠ½è±¡è¯­æ³•æ ‘AST
- ğŸ“Š **æ•°æ®å¯è§†åŒ–**ï¼šæ ‘å½¢ç»“æ„çš„å±‚æ¬¡åŒ–å±•ç¤º
- ğŸ® **æ¸¸æˆå¼€å‘**ï¼šæŠ€èƒ½æ ‘ã€è£…å¤‡æ ‘ç­‰å±‚æ¬¡ç»“æ„
- ğŸŒ **Webå¼€å‘**ï¼šDOMæ ‘çš„æ„å»ºå’Œéå†

---
*å­¦ä¹ æ—¥æœŸï¼š2024 | éš¾åº¦ï¼šâ­â­â­â˜†â˜†*