# 第13章 动态规划 - 练习题

## 目录
1. [最长公共子序列](#1-最长公共子序列)
2. [股票买卖的最佳时机](#2-股票买卖的最佳时机)
3. [编辑距离](#3-编辑距离)
4. [完全背包问题](#4-完全背包问题)
5. [矩阵链乘法](#5-矩阵链乘法)

---

## 1. 最长公共子序列
**难度：中等**

### 问题描述
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

### 核心思想
动态规划的经典二维问题：
- **状态定义**：`dp[i][j]` 表示 `text1[0...i-1]` 和 `text2[0...j-1]` 的最长公共子序列长度
- **状态转移**：
  - 如果 `text1[i-1] === text2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`
  - 否则：`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`
- **初始化**：`dp[0][j] = 0`，`dp[i][0] = 0`

### 示例
```javascript
输入：text1 = "abcde", text2 = "ace" 
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

输入：text1 = "abc", text2 = "abc"
输出：3

输入：text1 = "abc", text2 = "def"
输出：0
```

### 实现要求
1. 实现基础的二维DP解法
2. 实现空间优化的一维DP解法
3. 实现能够输出具体LCS字符串的版本
4. 分析时间复杂度和空间复杂度

### 知识点
- 二维动态规划
- 字符串处理
- 空间优化技巧
- 路径回溯

---

## 2. 股票买卖的最佳时机
**难度：中等**

### 问题描述
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易（买入和卖出一只股票为一笔交易）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 核心思想
状态机动态规划：
- **状态定义**：`dp[i][j][state]` 表示第i天进行了j次交易时的状态
  - `state = 0`：当前不持有股票
  - `state = 1`：当前持有股票
- **状态转移**：
  - 不持有：`dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])`
  - 持有：`dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])`

### 示例
```javascript
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，利润 = 4-2 = 2。

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天买入，第 3 天卖出，利润 = 6-2 = 4；在第 5 天买入，第 6 天卖出，利润 = 3-0 = 3。
```

### 实现要求
1. 实现通用的k次交易解法
2. 优化k很大时的情况（k >= n/2时相当于无限次交易）
3. 实现空间优化版本
4. 扩展到包含冷冻期和手续费的情况

### 知识点
- 状态机DP
- 多维状态设计
- 边界条件处理
- 空间优化

---

## 3. 编辑距离
**难度：困难**

### 问题描述
给定两个单词 `word1` 和 `word2`，请计算出将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作：
1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

### 核心思想
经典的字符串DP问题：
- **状态定义**：`dp[i][j]` 表示将 `word1[0...i-1]` 转换为 `word2[0...j-1]` 的最少操作数
- **状态转移**：
  - 如果 `word1[i-1] === word2[j-1]`：`dp[i][j] = dp[i-1][j-1]`
  - 否则：`dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`
    - `dp[i-1][j] + 1`：删除操作
    - `dp[i][j-1] + 1`：插入操作
    - `dp[i-1][j-1] + 1`：替换操作

### 示例
```javascript
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

输入：word1 = "intention", word2 = "execution"
输出：5
```

### 实现要求
1. 实现基础的编辑距离算法
2. 实现能够输出具体操作序列的版本
3. 扩展到支持不同操作的不同代价
4. 实现空间优化版本

### 知识点
- 二维动态规划
- 字符串匹配
- 操作序列记录
- 算法应用（拼写检查、DNA序列比对）

---

## 4. 完全背包问题
**难度：中等**

### 问题描述
有 `N` 种物品和一个容量为 `V` 的背包，每种物品都有无限件。第 `i` 种物品的体积是 `volume[i]`，价值是 `value[i]`。

求解将哪些物品装入背包可使这些物品的总体积不超过背包容量，且总价值最大。

### 核心思想
完全背包的动态规划解法：
- **状态定义**：`dp[i]` 表示容量为i的背包能获得的最大价值
- **状态转移**：对于每个物品j，`dp[i] = Math.max(dp[i], dp[i-volume[j]] + value[j])`
- **遍历顺序**：外层遍历物品，内层正序遍历容量

### 示例
```javascript
输入：
volume = [1, 3, 4]
value = [15, 20, 30]
capacity = 4

输出：60
解释：选择4个第1种物品，总价值 = 4 * 15 = 60

输入：
volume = [2, 3, 4, 5]
value = [3, 4, 5, 6]
capacity = 5

输出：7
解释：选择1个第2种物品和1个第1种物品，总价值 = 4 + 3 = 7
```

### 实现要求
1. 实现标准的完全背包算法
2. 实现能够输出选择方案的版本
3. 扩展到二维费用背包问题
4. 实现硬币找零等经典变形

### 知识点
- 完全背包DP
- 状态压缩
- 方案记录
- 问题变形与扩展

---

## 5. 矩阵链乘法
**难度：困难**

### 问题描述
给定一个代表矩阵链的数组 `p`，其中 `p[i-1]` 和 `p[i]` 代表第 `i` 个矩阵的维度。

求完全括号化矩阵链乘积所需的最少标量乘法次数。

例如，如果矩阵链为 `A1, A2, A3, A4`，对应的维度数组为 `p = [1, 2, 3, 4, 5]`，则矩阵 `A1` 的维度为 `1×2`，`A2` 的维度为 `2×3`，以此类推。

### 核心思想
区间动态规划的经典问题：
- **状态定义**：`dp[i][j]` 表示计算矩阵 `Ai` 到 `Aj` 的乘积所需的最少标量乘法次数
- **状态转移**：`dp[i][j] = Math.min(dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j])` 对所有 `k` 在 `[i, j-1]` 范围内
- **初始化**：`dp[i][i] = 0`（单个矩阵不需要乘法）

### 示例
```javascript
输入：p = [1, 2, 3, 4, 5]
输出：30
解释：矩阵维度分别为：A1(1×2), A2(2×3), A3(3×4), A4(4×5)
最优括号化：((A1A2)(A3A4))
乘法次数：1*2*3 + 3*4*5 + 1*3*5 = 6 + 60 + 15 = 81

更优的括号化：(A1((A2A3)A4))
乘法次数：2*3*4 + 2*4*5 + 1*2*5 = 24 + 40 + 10 = 74

最优括号化：(A1(A2(A3A4)))
乘法次数：3*4*5 + 2*3*5 + 1*2*5 = 60 + 30 + 10 = 100

实际最优：((A1A2)(A3A4)) = 30
```

### 实现要求
1. 实现基础的矩阵链乘法算法
2. 实现能够输出最优括号化方案的版本
3. 分析时间复杂度和空间复杂度
4. 扩展到其他区间DP问题

### 知识点
- 区间动态规划
- 最优子结构
- 枚举分割点
- 方案构造与输出

---

## 难度分布

| 难度 | 题目数量 | 题目编号 |
|------|----------|----------|
| 简单 | 0 | - |
| 中等 | 4 | 1, 2, 4, 5 |
| 困难 | 2 | 3, 5 |

## 核心知识点总结

### 1. DP状态设计
- 一维状态：序列问题
- 二维状态：双序列、背包问题
- 多维状态：复杂约束问题
- 状态机：有限状态转移

### 2. DP分类掌握
- **线性DP**：最长公共子序列、编辑距离
- **背包DP**：0-1背包、完全背包
- **区间DP**：矩阵链乘法
- **状态机DP**：股票买卖问题

### 3. 优化技巧
- **空间优化**：滚动数组、状态压缩
- **时间优化**：单调队列、矩阵快速幂
- **记忆化搜索**：递归 + 缓存

### 4. 实际应用
- 字符串处理（编辑距离、最长公共子序列）
- 资源分配（背包问题、股票交易）
- 路径规划（最短路径、最优决策）
- 游戏策略（博弈论、概率计算）

## 解题模板

### 线性DP模板
```javascript
function linearDP(arr) {
    const n = arr.length;
    const dp = new Array(n);
    
    // 初始化
    dp[0] = /* 基础情况 */;
    
    // 状态转移
    for (let i = 1; i < n; i++) {
        dp[i] = /* 根据前面的状态计算 */;
    }
    
    return dp[n-1];
}
```

### 二维DP模板
```javascript
function twoDimensionDP(s1, s2) {
    const m = s1.length, n = s2.length;
    const dp = Array(m+1).fill().map(() => Array(n+1).fill(0));
    
    // 初始化边界
    for (let i = 0; i <= m; i++) dp[i][0] = /* 边界值 */;
    for (let j = 0; j <= n; j++) dp[0][j] = /* 边界值 */;
    
    // 状态转移
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            dp[i][j] = /* 转移方程 */;
        }
    }
    
    return dp[m][n];
}
```

### 背包DP模板
```javascript
function knapsack(weights, values, capacity) {
    const dp = new Array(capacity + 1).fill(0);
    
    for (let i = 0; i < weights.length; i++) {
        // 0-1背包：逆序遍历
        for (let w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
        
        // 完全背包：正序遍历
        // for (let w = weights[i]; w <= capacity; w++) {
        //     dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        // }
    }
    
    return dp[capacity];
}
``` 