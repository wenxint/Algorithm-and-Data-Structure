# 第5章练习题：二叉树基础

本章练习题精选了5道典型的二叉树问题，涵盖遍历、路径、构造和属性检查等核心算法思想。

## 题目1：二叉树的前序遍历（简单）

给你二叉树的根节点 `root`，返回它节点值的**前序**遍历。

**示例 1：**
```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**
```
输入：root = []
输出：[]
```

**示例 3：**
```
输入：root = [1]
输出：[1]
```

**核心思想：**
前序遍历的访问顺序是"根-左-右"，可以用递归或迭代两种方式实现。递归方式更直观，迭代方式使用栈模拟递归过程。

**要求：**
- 请同时实现递归和迭代两种解法
- 时间复杂度：O(n)
- 空间复杂度：O(h)，h为树的高度

**学习要点：**
- 理解前序遍历的特点和应用场景
- 掌握递归和迭代两种实现方式
- 理解栈在迭代实现中的作用

---

## 题目2：路径总和（简单）

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum`。判断该树中是否存在**根节点到叶子节点**的路径，这条路径上所有节点值相加等于目标和 `targetSum`。

**叶子节点**是指没有子节点的节点。

**示例 1：**
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**
```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**核心思想：**
使用递归向下传递剩余目标值，每经过一个节点就减去该节点的值。当到达叶子节点时，检查剩余目标值是否等于叶子节点的值。

**要求：**
- 使用递归算法
- 时间复杂度：O(n)
- 空间复杂度：O(h)

**学习要点：**
- 理解路径问题的递归思想
- 掌握在递归中传递状态的技巧
- 理解叶子节点的判断条件

---

## 题目3：从前序与中序遍历序列构造二叉树（中等）

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的**前序遍历**，`inorder` 是同一棵树的**中序遍历**，请构造并返回这颗**二叉树**。

**示例 1：**
```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2：**
```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**核心思想：**
利用前序遍历和中序遍历的特点：前序遍历的第一个元素是根节点，根据这个根节点在中序遍历中的位置可以确定左右子树的范围。然后递归地构造左右子树。

**要求：**
- 使用分治法递归实现
- 时间复杂度：O(n)
- 空间复杂度：O(n)

**学习要点：**
- 理解不同遍历方式的特点
- 掌握分治法的思想
- 学会利用遍历特性解决构造问题

---

## 题目4：平衡二叉树（简单）

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点*的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：**
```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**
```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**核心思想：**
使用后序遍历，先检查左右子树是否平衡，然后计算当前节点的高度差。如果发现不平衡的子树，可以提前返回结果进行优化。

**要求：**
- 实现基础版本和优化版本
- 基础版本时间复杂度：O(n²)
- 优化版本时间复杂度：O(n)
- 空间复杂度：O(h)

**学习要点：**
- 理解后序遍历在属性检查中的应用
- 掌握高度计算的递归方法
- 学会优化算法避免重复计算

---

## 题目5：二叉树中的最大路径和（困难）

**路径**被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中**至多出现一次**。该路径**至少包含一个**节点，且不一定经过根节点。

**路径和**是路径中各节点值的总和。

给你一个二叉树的根节点 `root`，返回其**最大路径和**。

**示例 1：**
```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**
```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**核心思想：**
对于每个节点，最大路径和可能的情况有：1) 只包含当前节点；2) 包含当前节点和左子树；3) 包含当前节点和右子树；4) 包含当前节点、左子树和右子树。使用递归计算每个节点作为路径端点时的最大贡献值，同时维护全局最大路径和。

**要求：**
- 使用递归算法
- 维护全局状态
- 时间复杂度：O(n)
- 空间复杂度：O(h)

**学习要点：**
- 理解路径问题的状态定义
- 掌握全局状态维护的技巧
- 学会处理负数节点的情况

---

## 总结

这5道题目涵盖了二叉树的核心算法思想：

1. **遍历算法**：前序遍历展示了树的基本访问模式
2. **路径问题**：路径总和体现了状态传递的思想
3. **构造算法**：从遍历序列构造树展示了分治法的应用
4. **属性计算**：平衡树检查展示了后序遍历在属性检查中的价值
5. **优化策略**：最大路径和展示了如何在递归中维护全局状态

**难度分布**：简单题3道，中等题1道，困难题1道，符合循序渐进的学习原则。

**核心收获**：
- 掌握递归在二叉树中的应用模式
- 理解不同遍历方式的特点和应用场景
- 学会在递归中传递和维护状态
- 掌握分治法解决构造问题的思路 