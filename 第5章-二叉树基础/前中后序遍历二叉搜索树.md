# 前中后序遍历二叉搜索树

## 章节概述 📚

二叉树的遍历是树操作中最基础也是最重要的概念之一。遍历就是按照某种规则访问树中的每个节点，确保每个节点都被访问且仅被访问一次。本章将详细介绍三种经典的深度优先遍历方式：前序遍历、中序遍历和后序遍历，重点讲解它们在二叉搜索树中的特殊性质和应用场景。

## 遍历基础概念 🔧

### 什么是二叉树遍历

二叉树遍历是指按照某种规则系统地访问二叉树中每个节点的过程。对于每个节点，我们需要决定访问该节点、其左子树和右子树的顺序。

### 三种遍历方式的定义

根据访问根节点的时机不同，深度优先遍历分为三种：

1. **前序遍历（Pre-order）**：根节点 → 左子树 → 右子树
2. **中序遍历（In-order）**：左子树 → 根节点 → 右子树
3. **后序遍历（Post-order）**：左子树 → 右子树 → 根节点

## 前序遍历（Pre-order Traversal） 🎯

### 核心思想

前序遍历的核心思想是"根先行"，即先访问根节点，再递归地访问左子树，最后访问右子树。这种遍历方式常用于需要先处理父节点再处理子节点的场景。

### 算法步骤

1. 访问当前节点（处理节点数据）
2. 递归遍历左子树
3. 递归遍历右子树

### 递归实现

```javascript
/**
 * 前序遍历二叉搜索树（递归实现）
 *
 * 核心思想：
 * 采用"根-左-右"的访问顺序，先处理当前节点，再递归处理子树
 * 这种遍历方式适合用于复制树结构、计算树的深度等操作
 *
 * @param {Node} node - 当前访问的节点
 * @param {Function} callback - 处理节点的回调函数
 * @time O(n) - 需要访问每个节点一次
 * @space O(h) - 递归栈深度为树的高度h
 */
function preOrderTraverse(node, callback = (key) => console.log(key)) {
    if (node !== null) {
        callback(node.key);                    // 1. 访问根节点
        preOrderTraverse(node.left, callback); // 2. 遍历左子树
        preOrderTraverse(node.right, callback);// 3. 遍历右子树
    }
}

// 调用示例
const tree = createSampleTree(); // 假设已创建树: [15,10,20,8,12,17,25]
console.log("前序遍历结果:");
preOrderTraverse(tree.root);
// 输出: 15 → 10 → 8 → 12 → 20 → 17 → 25
```

### 迭代实现

```javascript
/**
 * 前序遍历二叉搜索树（迭代实现）
 *
 * 核心思想：
 * 使用栈来模拟递归过程，先将根节点入栈
 * 每次出栈一个节点并访问，然后将其右子节点和左子节点依次入栈
 * （注意：先入栈右子节点，后入栈左子节点，因为栈是后进先出）
 *
 * @param {Node} root - 树的根节点
 * @param {Function} callback - 处理节点的回调函数
 */
function preOrderTraverseIterative(root, callback = (key) => console.log(key)) {
    if (root === null) return;

    const stack = [root]; // 初始化栈，放入根节点

    while (stack.length > 0) {
        const current = stack.pop(); // 取出栈顶节点
        callback(current.key);       // 访问当前节点

        // 先压入右子节点，再压入左子节点（保证左子节点先被访问）
        if (current.right !== null) {
            stack.push(current.right);
        }
        if (current.left !== null) {
            stack.push(current.left);
        }
    }
}
```

## 中序遍历（In-order Traversal） 🎯

### 核心思想

中序遍历的核心思想是"左根右"的访问顺序。对于二叉搜索树来说，中序遍历有特殊的重要性：**它会产生一个有序的序列**。这是二叉搜索树最重要的性质之一。

### 算法步骤

1. 递归遍历左子树
2. 访问当前节点（处理节点数据）
3. 递归遍历右子树

### 递归实现

```javascript
/**
 * 中序遍历二叉搜索树（递归实现）
 *
 * 核心思想：
 * 采用"左-根-右"的访问顺序，这是二叉搜索树最重要的遍历方式
 * 对于二叉搜索树，中序遍历会产生一个升序排列的序列
 *
 * 应用场景：
 * - 获取树中所有元素的有序序列
 * - 验证二叉搜索树的正确性
 * - 查找第k小的元素
 *
 * @param {Node} node - 当前访问的节点
 * @param {Function} callback - 处理节点的回调函数
 * @time O(n) - 需要访问每个节点一次
 * @space O(h) - 递归栈深度为树的高度h
 */
function inOrderTraverse(node, callback = (key) => console.log(key)) {
    if (node !== null) {
        inOrderTraverse(node.left, callback);  // 1. 遍历左子树
        callback(node.key);                    // 2. 访问根节点
        inOrderTraverse(node.right, callback); // 3. 遍历右子树
    }
}

// 调用示例
const tree = createSampleTree(); // 树: [15,10,20,8,12,17,25]
console.log("中序遍历结果（有序）:");
inOrderTraverse(tree.root);
// 输出: 8 → 10 → 12 → 15 → 17 → 20 → 25（升序排列）
```

### 迭代实现

```javascript
/**
 * 中序遍历二叉搜索树（迭代实现）
 *
 * 核心思想：
 * 使用栈来模拟递归，先一直往左走到最左边的节点
 * 然后访问该节点，再转向其右子树
 *
 * @param {Node} root - 树的根节点
 * @param {Function} callback - 处理节点的回调函数
 */
function inOrderTraverseIterative(root, callback = (key) => console.log(key)) {
    const stack = [];
    let current = root;

    while (current !== null || stack.length > 0) {
        // 一直往左走，将路径上的节点都入栈
        while (current !== null) {
            stack.push(current);
            current = current.left;
        }

        // 访问栈顶节点（最左边的节点）
        current = stack.pop();
        callback(current.key);

        // 转向右子树
        current = current.right;
    }
}
```

## 后序遍历（Post-order Traversal） 🎯

### 核心思想

后序遍历的核心思想是"左右根"的访问顺序，即先处理子节点，最后处理父节点。这种遍历方式常用于需要先处理子节点再处理父节点的场景，如计算目录大小、删除树节点等。

### 算法步骤

1. 递归遍历左子树
2. 递归遍历右子树
3. 访问当前节点（处理节点数据）

### 递归实现

```javascript
/**
 * 后序遍历二叉搜索树（递归实现）
 *
 * 核心思想：
 * 采用"左-右-根"的访问顺序，先处理子树，最后处理根节点
 * 这种遍历方式适合用于删除树、计算子树大小等需要"自底向上"处理的场景
 *
 * 应用场景：
 * - 删除整棵树（先删子节点再删父节点）
 * - 计算每个节点的子树大小
 * - 计算目录的总大小
 *
 * @param {Node} node - 当前访问的节点
 * @param {Function} callback - 处理节点的回调函数
 * @time O(n) - 需要访问每个节点一次
 * @space O(h) - 递归栈深度为树的高度h
 */
function postOrderTraverse(node, callback = (key) => console.log(key)) {
    if (node !== null) {
        postOrderTraverse(node.left, callback); // 1. 遍历左子树
        postOrderTraverse(node.right, callback);// 2. 遍历右子树
        callback(node.key);                     // 3. 访问根节点
    }
}

// 调用示例
const tree = createSampleTree(); // 树: [15,10,20,8,12,17,25]
console.log("后序遍历结果:");
postOrderTraverse(tree.root);
// 输出: 8 → 12 → 10 → 17 → 25 → 20 → 15
```

### 迭代实现

```javascript
/**
 * 后序遍历二叉搜索树（迭代实现）
 *
 * 核心思想：
 * 后序遍历的迭代实现相对复杂，需要确保在访问根节点之前，
 * 其左右子树都已经被访问过。使用两个栈或标记来实现。
 *
 * @param {Node} root - 树的根节点
 * @param {Function} callback - 处理节点的回调函数
 */
function postOrderTraverseIterative(root, callback = (key) => console.log(key)) {
    if (root === null) return;

    const stack1 = [root];
    const stack2 = [];

    // 第一个栈用于遍历，第二个栈用于存储结果
    while (stack1.length > 0) {
        const current = stack1.pop();
        stack2.push(current);

        // 先放左子节点，再放右子节点
        if (current.left !== null) {
            stack1.push(current.left);
        }
        if (current.right !== null) {
            stack1.push(current.right);
        }
    }

    // 第二个栈的内容就是后序遍历的结果
    while (stack2.length > 0) {
        const node = stack2.pop();
        callback(node.key);
    }
}
```

## 三种遍历方式的对比分析 💡

### 可视化理解

对于以下二叉搜索树：

    15
   /  \
  10   20
 / \   / \
8  12 17 25
```

### 遍历结果对比

| 遍历方式 | 访问顺序 | 结果序列 | 特点 |
|---------|---------|---------|------|
| 前序遍历 | 根-左-右 | 15→10→8→12→20→17→25 | 根节点总是最先被访问 |
| 中序遍历 | 左-根-右 | 8→10→12→15→17→20→25 | **产生有序序列**（BST特性） |根节点总是被中间访问
| 后序遍历 | 左-右-根 | 8→12→10→17→25→20→15 | 根节点总是最后被访问 |

### 应用场景总结

#### 前序遍历的应用
- **复制树结构**：需要先创建根节点再创建子树
- **计算树的高度**：需要先处理当前节点
- **前缀表达式求值**：运算符在操作数前面

```javascript
// 示例：使用前序遍历复制树
function cloneTree(node) {
    if (node === null) return null;

    const newNode = new Node(node.key);  // 先创建根节点
    newNode.left = cloneTree(node.left);  // 再复制左子树
    newNode.right = cloneTree(node.right); // 最后复制右子树

    return newNode;
}
```
#### 中序遍历的应用

- **获取有序序列**：这是BST最重要的特性
- **验证BST的正确性**：检查遍历结果是否有序
- **查找第k小的元素**：遍历到第k个元素即可

```javascript
// 示例：验证是否为有效的二叉搜索树
function isValidBST(root) {
    const values = [];
    inOrderTraverse(root, (key) => values.push(key));

    // 检查是否严格递增
    for (let i = 1; i < values.length; i++) {
        if (values[i] <= values[i-1]) {
            return false;
        }
    }
    return true;
}
```
#### 后序遍历的应用

- **删除树节点**：需要先删除子节点再删除父节点
- **计算子树大小**：需要先知道子树的信息
- **后缀表达式求值**：运算符在操作数后面

```javascript
// 示例：计算每个节点的子树大小
function calculateSubtreeSize(node) {
    if (node === null) return 0;

    const leftSize = calculateSubtreeSize(node.left);   // 左子树大小
    const rightSize = calculateSubtreeSize(node.right); // 右子树大小

    node.subtreeSize = leftSize + rightSize + 1; // 当前子树大小
    return node.subtreeSize;
}
```
## 复杂度分析对比 🎯

### 时间复杂度

所有三种遍历方式的时间复杂度都是 **O(n)**，因为每个节点都需要被访问一次。

### 空间复杂度


| 实现方式 | 空间复杂度 | 说明                      |
| -------- | ---------- | ------------------------- |
| 递归实现 | O(h)       | h为树的高度，递归栈的深度 |
| 迭代实现 | O(h)       | 显式栈的最大大小          |
| 平衡树   | O(log n)   | 高度为log n               |
| 最坏情况 | O(n)       | 退化为链表时，高度为n     |

## 完整的实现示例

```javascript
class TreeNode {
    constructor(key) {
        this.key = key;
        this.left = null;
        this.right = null;
    }
}

class BinarySearchTree {
    constructor() {
        this.root = null;
    }

    // 插入节点
    insert(key) {
        this.root = this.insertNode(this.root, key);
    }

    insertNode(node, key) {
        if (node === null) {
            return new TreeNode(key);
        }

        if (key < node.key) {
            node.left = this.insertNode(node.left, key);
        } else {
            node.right = this.insertNode(node.right, key);
        }

        return node;
    }

    // 前序遍历
    preOrder(callback = (key) => console.log(key)) {
        this.preOrderTraverse(this.root, callback);
    }

    preOrderTraverse(node, callback) {
        if (node !== null) {
            callback(node.key);
            this.preOrderTraverse(node.left, callback);
            this.preOrderTraverse(node.right, callback);
        }
    }

    // 中序遍历
    inOrder(callback = (key) => console.log(key)) {
        this.inOrderTraverse(this.root, callback);
    }

    inOrderTraverse(node, callback) {
        if (node !== null) {
            this.inOrderTraverse(node.left, callback);
            callback(node.key);
            this.inOrderTraverse(node.right, callback);
        }
    }

    // 后序遍历
    postOrder(callback = (key) => console.log(key)) {
        this.postOrderTraverse(this.root, callback);
    }

    postOrderTraverse(node, callback) {
        if (node !== null) {
            this.postOrderTraverse(node.left, callback);
            this.postOrderTraverse(node.right, callback);
            callback(node.key);
        }
    }
}

// 测试示例
const bst = new BinarySearchTree();
const values = [15, 10, 20, 8, 12, 17, 25];

// 构建树
values.forEach(value => bst.insert(value));

console.log("前序遍历：");
bst.preOrder(); // 15 10 8 12 20 17 25

console.log("中序遍历（有序）：");
bst.inOrder();  // 8 10 12 15 17 20 25

console.log("后序遍历：");
bst.postOrder(); // 8 12 10 17 25 20 15
```
## 学习要点总结

1. **理解遍历的本质**：遍历就是系统地访问每个节点
2. **掌握递归思想**：每种遍历都可以用递归优雅地实现
3. **记住中序遍历的特殊性**：对BST中序遍历产生有序序列
4. **理解应用场景**：不同遍历方式适用于不同的问题
5. **练习递归和迭代实现**：加深对算法的理解

通过掌握这三种遍历方式，你就具备了处理树结构问题的基础工具，为后续学习更复杂的树算法打下坚实基础。
