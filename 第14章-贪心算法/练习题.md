# 第14章 贪心算法 - 练习题

## 目录
1. [跳跃游戏II](#problem1) - 中等
2. [重构字符串](#problem2) - 中等  
3. [分发饼干](#problem3) - 简单
4. [任务调度器](#problem4) - 中等
5. [会议室II](#problem5) - 中等

---

## 问题1：跳跃游戏II {#problem1}

### 问题描述
给你一个非负整数数组 `nums`，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。

### 核心思想
**贪心策略**：在当前跳跃范围内，选择能够到达最远位置的点作为下一跳的起点。

**算法思想**：
- 维护当前跳跃能够到达的边界
- 在到达边界之前，记录在当前范围内能够跳跃到的最远位置
- 一旦到达边界，更新边界为最远位置，跳跃次数加1

### 示例
**输入**: `nums = [2,3,1,1,4]`
**输出**: `2`
**解释**: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

### 实现要求
1. 实现 `jump(nums)` 函数，返回最少跳跃次数
2. 时间复杂度要求：O(n)
3. 空间复杂度要求：O(1)
4. 处理边界情况：数组长度为1的情况

### 核心知识点
- 贪心算法的局部最优选择
- 范围更新技巧
- 边界处理

---

## 问题2：重构字符串 {#problem2}

### 问题描述
给定一个字符串 `s`，检查是否能重新排布其中的字母，使得两相邻的字符不同。若可行，输出任意可行的结果。若不可行，返回空字符串。

### 核心思想
**贪心策略**：优先放置出现频率最高的字符，采用间隔放置的方式避免相邻。

**算法思想**：
- 统计每个字符的出现频率
- 如果最高频率字符的数量超过 `(n+1)/2`，则无法重构
- 先在偶数位置放置频率最高的字符
- 然后依次放置其他字符，偶数位置放满后放置奇数位置

### 示例
**输入**: `s = "aab"`
**输出**: `"aba"`

**输入**: `s = "aaab"`
**输出**: `""` （无法重构）

### 实现要求
1. 实现 `reorganizeString(s)` 函数
2. 时间复杂度：O(n)
3. 空间复杂度：O(1)（字符集大小固定）
4. 考虑字符串长度为1的特殊情况

### 核心知识点
- 频率统计与分析
- 间隔放置策略
- 贪心选择的正确性证明

---

## 问题3：分发饼干 {#problem3}

### 问题描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]`。如果 `s[j] >= g[i]`，我们可以将这块饼干 `j` 分配给孩子 `i`，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

### 核心思想
**贪心策略**：用最小的饼干满足胃口最小的孩子。

**算法思想**：
- 将孩子的胃口值和饼干尺寸都按升序排序
- 用双指针分别指向孩子和饼干
- 如果当前饼干能满足当前孩子，两个指针都向前移动
- 否则，只移动饼干指针寻找更大的饼干

### 示例
**输入**: `g = [1,2,3]`, `s = [1,1]`
**输出**: `1`
**解释**: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。

### 实现要求
1. 实现 `findContentChildren(g, s)` 函数
2. 时间复杂度：O(n log n + m log m)
3. 空间复杂度：O(1)
4. 处理空数组的情况

### 核心知识点
- 排序在贪心算法中的应用
- 双指针技术
- 贪心选择的最优性

---

## 问题4：任务调度器 {#problem4}

### 问题描述
给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。

在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个相同种类的任务之间必须有长度为整数 `n` 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

### 核心思想
**贪心策略**：优先安排频率最高的任务，确保相同任务间有足够的冷却时间。

**算法思想**：
- 找到出现频率最高的任务
- 以最高频率任务为框架，计算最少需要的时间片
- 其他任务尽可能填充空闲时间片
- 如果其他任务足够多，直接返回任务总数

### 示例
**输入**: `tasks = ["A","A","A","B","B","B"]`, `n = 2`
**输出**: `8`
**解释**: A -> B -> idle -> A -> B -> idle -> A -> B

### 实现要求
1. 实现 `leastInterval(tasks, n)` 函数
2. 时间复杂度：O(m)，m是任务总数
3. 空间复杂度：O(1)（字符集大小固定）
4. 考虑n=0的特殊情况

### 核心知识点
- 频率分析与数学计算
- 时间片安排策略
- 贪心算法的数学证明

---

## 问题5：会议室II {#problem5}

### 问题描述
给你一个会议时间安排的数组 `intervals`，每个会议时间都会包括开始和结束的时间 `intervals[i] = [starti, endi]`，请你返回所需会议室的最小数量。

### 核心思想
**贪心策略**：将会议的开始和结束时间分别处理，使用事件排序的方法。

**算法思想**：
- 将所有开始时间和结束时间作为事件点
- 开始时间对应+1（需要新会议室），结束时间对应-1（释放会议室）
- 按时间顺序处理所有事件，记录同时进行的最大会议数量
- 注意：结束时间应该优先于相同时间的开始时间处理

### 示例
**输入**: `intervals = [[0,30],[5,10],[15,20]]`
**输出**: `2`
**解释**: 需要两个会议室

### 实现要求
1. 实现 `minMeetingRooms(intervals)` 函数
2. 时间复杂度：O(n log n)
3. 空间复杂度：O(n)
4. 处理空数组和单个会议的情况

### 核心知识点
- 事件排序技巧
- 扫描线算法思想
- 区间问题的贪心处理

---

## 总结

| 题目 | 难度 | 核心技巧 | 时间复杂度 |
|------|------|----------|------------|
| 跳跃游戏II | 中等 | 范围更新贪心 | O(n) |
| 重构字符串 | 中等 | 频率贪心+间隔放置 | O(n) |
| 分发饼干 | 简单 | 排序+双指针 | O(n log n) |
| 任务调度器 | 中等 | 频率分析+数学计算 | O(n) |
| 会议室II | 中等 | 事件排序+扫描线 | O(n log n) |

**难度分布**: 简单(1) + 中等(4) = 5题

这些练习题涵盖了贪心算法的核心应用场景：区间调度、频率处理、资源分配和时间安排等，帮助深入理解贪心算法的设计思想和应用技巧。 