# 第4章：哈希表 - 练习题

本章练习题重点训练哈希表的核心应用：快速查找、频次统计、分组归类、前缀和和缓存优化。通过5道精选题目，全面掌握哈希表的算法思想和实际应用。

## 题目1：两数之和（简单）

**问题描述**：
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

**核心思想**：
利用哈希表的O(1)查找特性，避免双重循环的O(n²)时间复杂度。

**示例**：
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]

输入：nums = [3,2,4], target = 6
输出：[1,2]

输入：nums = [3,3], target = 6
输出：[0,1]
```

**复杂度要求**：
- 时间复杂度：O(n)
- 空间复杂度：O(n)

**学习重点**：掌握哈希表快速查找的基本思想

---

## 题目2：有效的字母异位词（简单）

**问题描述**：
给定两个字符串 `s` 和 `t`，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意**：若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

**核心思想**：
异位词的字符频次完全相同，使用哈希表统计和比较字符频次。

**示例**：
```
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```

**复杂度要求**：
- 时间复杂度：O(n)
- 空间复杂度：O(1) - 最多26个小写字母

**学习重点**：掌握哈希表频次统计的应用，思考排序解法与哈希表解法的区别

---

## 题目3：字母异位词分组（中等）

**问题描述**：
给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。

字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。

**核心思想**：
使用哈希表进行分组，排序后的字符串或字符频次作为分组键。

**示例**：
```
输入: strs = ["eat","tea","tan","ate","nat","bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

输入: strs = [""]
输出: [[""]]

输入: strs = ["a"]
输出: [["a"]]
```

**复杂度要求**：
- 时间复杂度：O(n * k log k) - n个字符串，每个长度k需要排序
- 空间复杂度：O(n * k)

**学习重点**：掌握哈希表分组归类的思想，对比排序键和频次键两种方法

---

## 题目4：和为K的子数组（中等）

**问题描述**：
给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

**核心思想**：
前缀和 + 哈希表的经典组合，将子数组和问题转换为前缀和差值问题。

**示例**：
```
输入：nums = [1,1,1], k = 2
输出：2

输入：nums = [1,2,3], k = 3
输出：2
```

**复杂度要求**：
- 时间复杂度：O(n)
- 空间复杂度：O(n)

**学习重点**：理解前缀和的数学原理，掌握前缀和+哈希表解决子数组问题的模式

---

## 题目5：LRU缓存（困难）

**问题描述**：
请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。

实现 `LRUCache` 类：
- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 -1
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**核心思想**：
哈希表 + 双向链表的组合数据结构，哈希表提供O(1)查找，双向链表维护访问顺序。

**示例**：
```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**复杂度要求**：
- 时间复杂度：get 和 put 都是 O(1)
- 空间复杂度：O(capacity)

**学习重点**：理解LRU缓存的设计思想，掌握哈希表与双向链表结合使用的高级技巧

---

## 总结

这5道题目覆盖了哈希表的核心应用场景：

1. **快速查找**：两数之和 - 基础的哈希表查找应用
2. **频次统计**：有效的字母异位词 - 字符频次统计和比较
3. **分组归类**：字母异位词分组 - 使用哈希表进行数据分组
4. **前缀和优化**：和为K的子数组 - 前缀和与哈希表的结合
5. **缓存设计**：LRU缓存 - 综合数据结构设计

通过这些练习，你将全面掌握哈希表在算法问题中的应用模式，为面试和实际开发打下坚实基础。 