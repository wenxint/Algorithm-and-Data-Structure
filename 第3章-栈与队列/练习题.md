# 第3章：栈与队列 - 练习题

本章精选5道题目，涵盖栈和队列的核心应用场景：

## 题目1：有效的括号（简单）

### 题目描述
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s`，判断字符串是否有效。

有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合
2. 左括号必须以正确的顺序闭合
3. 每个右括号都有一个对应的相同类型的左括号

### 核心思想
使用栈来匹配括号对：
- 遇到左括号时压入栈中
- 遇到右括号时检查栈顶是否为对应的左括号
- 最终栈为空则所有括号都正确匹配

### 示例
```
输入：s = "()"
输出：true

输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false

输入：s = "([)]"
输出：false
```

### 要求
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 学习要点
- 栈的基本应用：配对匹配
- 字符串遍历和条件判断
- 栈空判断的重要性

---

## 题目2：用栈实现队列（简单）

### 题目描述
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：
- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 true；否则，返回 false

### 核心思想
使用两个栈模拟队列的FIFO特性：
- 输入栈：负责接收新元素
- 输出栈：负责弹出元素
- 当输出栈为空时，将输入栈的所有元素转移到输出栈

### 示例
```
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2]
myQueue.peek();  // return 1
myQueue.pop();   // return 1, queue is [2]
myQueue.empty(); // return false
```

### 要求
- push操作时间复杂度：O(1)
- pop操作摊还时间复杂度：O(1)
- 空间复杂度：O(n)

### 学习要点
- 双栈模拟队列的经典技巧
- 摊还复杂度分析
- 数据结构之间的相互模拟

---

## 题目3：每日温度（中等）

### 题目描述
给定一个整数数组 `temperatures`，表示每天的温度，返回一个数组 `answer`，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

### 核心思想
使用单调栈解决"下一个更大元素"问题：
- 维护一个单调递减栈，存储温度的索引
- 当遇到更高温度时，栈中所有较低温度都找到了答案
- 计算索引差值得到等待天数

### 示例
```
输入：temperatures = [73,74,75,71,69,72,76,73]
输出：[1,1,4,2,1,1,0,0]

解释：
第0天：73°C，第1天74°C更高，等待1天
第1天：74°C，第2天75°C更高，等待1天
第2天：75°C，第6天76°C更高，等待4天
...
```

### 要求
- 时间复杂度：O(n) - 每个元素最多入栈出栈一次
- 空间复杂度：O(n) - 栈的空间

### 学习要点
- 单调栈的经典应用
- "下一个更大元素"问题的通用解法
- 栈中存储索引而非值的技巧

---

## 题目4：二叉树的层序遍历（中等）

### 题目描述
给你二叉树的根节点 `root`，返回其节点值的层序遍历。即逐层地，从左到右访问所有节点。

### 核心思想
使用队列进行广度优先搜索：
- 根节点入队
- 每次处理一层的所有节点
- 将当前层节点的子节点加入下一层
- 队列的FIFO特性保证层序访问

### 示例
```
输入：root = [3,9,20,null,null,15,7]
      3
     / \
    9  20
      /  \
     15   7

输出：[[3],[9,20],[15,7]]
```

### 要求
- 时间复杂度：O(n) - 访问每个节点一次
- 空间复杂度：O(w) - w为树的最大宽度

### 学习要点
- BFS算法的经典应用
- 队列在树遍历中的使用
- 按层分组处理的技巧

---

## 题目5：滑动窗口最大值（困难）

### 题目描述
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

### 核心思想
使用双端队列维护单调递减序列：
- 队列存储可能成为窗口最大值的元素索引
- 队头始终是当前窗口的最大值
- 移除超出窗口范围的元素
- 维护队列的单调递减性

### 示例
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]

解释：
滑动窗口的位置              最大值
[1  3  -1] -3  5  3  6  7    3
 1 [3  -1  -3] 5  3  6  7    3
 1  3 [-1  -3  5] 3  6  7    5
 1  3  -1 [-3  5  3] 6  7    5
 1  3  -1  -3 [5  3  6] 7    6
 1  3  -1  -3  5 [3  6  7]   7
```

### 要求
- 时间复杂度：O(n) - 每个元素最多入队出队一次
- 空间复杂度：O(k) - 双端队列最多存储k个元素

### 学习要点
- 双端队列的高级应用
- 单调队列维护区间最值
- 滑动窗口问题的优化技巧
- 时间复杂度的摊还分析

---

## 总结

这5道题目涵盖了栈和队列的核心应用场景：

1. **栈的基础应用**：括号匹配、配对问题
2. **数据结构模拟**：用栈实现队列，理解不同数据结构的特性
3. **单调栈技术**：解决"下一个更大元素"类问题
4. **BFS遍历**：队列在树遍历中的经典应用
5. **高级队列技巧**：双端队列解决滑动窗口问题

掌握这些题目的解题思路，能够帮助你深入理解栈和队列的本质特性，以及它们在算法设计中的重要作用。 