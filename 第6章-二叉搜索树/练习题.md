# 第6章：二叉搜索树 - 练习题

本章练习题重点考查二叉搜索树的核心操作和算法思想，包括搜索、插入、删除、范围查询、转换等重要概念。

## 题目1：验证二叉搜索树

### 题目描述
给定一个二叉树的根节点 `root`，判断其是否是一个有效的二叉搜索树。

**有效 BST 定义**：
- 节点的左子树只包含小于当前节点的数
- 节点的右子树只包含大于当前节点的数  
- 所有左子树和右子树自身必须也是二叉搜索树

### 核心思想
使用上下界限制每个节点的取值范围，递归验证左右子树时更新边界。BST的关键性质是每个节点都有一个有效的取值范围。

### 示例
```
输入：root = [2,1,3]
输出：true

输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值为 5，但是其右子节点值为 4
```

### 要求
- 时间复杂度：O(n)
- 空间复杂度：O(h)，h 为树的高度
- 考虑边界情况：空树、单节点、包含重复值的情况

### 学习要点
- 理解BST的定义和性质
- 掌握递归验证的边界更新技巧
- 学会使用上下界约束节点值范围

---

## 题目2：二叉搜索树中第K小的元素

### 题目描述
给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

### 核心思想
利用BST中序遍历得到有序序列的性质，使用计数器在遍历过程中找到第k个元素，避免完整遍历提高效率。

### 示例
```
输入：root = [3,1,4,null,2], k = 1
输出：1

输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

### 要求
- 实现递归版本和迭代版本两种解法
- 时间复杂度：O(h + k)，h 为树的高度
- 空间复杂度：O(h)
- 考虑优化：如果频繁查询，如何改进数据结构

### 学习要点
- 深刻理解BST中序遍历的有序性
- 掌握提前终止递归的技巧
- 学会使用栈模拟递归过程

---

## 题目3：将有序数组转换为二叉搜索树

### 题目描述
给你一个整数数组 `nums`，其中元素已经按**升序**排列，请你将其转换为一棵**高度平衡**的二叉搜索树。

**高度平衡**二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。

### 核心思想
选择数组中位数作为根节点，递归构造左右子树。这样可以保证构造出的BST是平衡的，因为每次都选择中位数作为根。

### 示例
```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：可能的答案是 [0,-10,5,null,-3,null,9] 等

输入：nums = [1,3]
输出：[3,1] 或 [1,null,3]
```

### 要求
- 时间复杂度：O(n)
- 空间复杂度：O(log n)，递归栈空间
- 构造的BST必须是高度平衡的
- 处理数组长度为奇数和偶数的情况

### 学习要点
- 理解平衡BST的重要性
- 掌握分治算法的应用
- 学会递归构造树结构的技巧

---

## 题目4：二叉搜索树的范围和

### 题目描述
给定二叉搜索树的根结点 `root`，返回值位于范围 `[low, high]` 之间的所有结点的值的和。

### 核心思想
利用BST的有序性质，只搜索可能包含目标值的子树。通过比较当前节点值与范围边界，决定是否需要搜索左右子树，避免无效搜索。

### 示例
```
输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32

输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出：23
```

### 要求
- 时间复杂度：O(n)，但实际效率高于完整遍历
- 空间复杂度：O(h)，h 为树的高度
- 充分利用BST性质进行剪枝
- 考虑范围完全不在树中的情况

### 学习要点
- 掌握BST剪枝搜索的技巧
- 理解如何利用有序性优化搜索
- 学会设计高效的范围查询算法

---

## 题目5：恢复二叉搜索树

### 题目描述
给你二叉搜索树的根节点 `root`，该树中的**恰好**两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树。

### 核心思想
如果BST中有两个节点位置错误，中序遍历时会出现降序对。通过一次中序遍历找到这两个错误节点，然后交换它们的值。

### 示例
```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1。交换 1 和 3 使二叉搜索树有效。

输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3。交换 2 和 3 使二叉搜索树有效。
```

### 要求
- 时间复杂度：O(n)
- 空间复杂度：O(h)，不使用额外的数组存储
- 只能交换节点的值，不能改变树的结构
- 考虑两个错误节点相邻和不相邻的情况

### 学习要点
- 深入理解BST中序遍历的性质
- 掌握在遍历过程中检测异常的技巧
- 学会分析和处理复杂的树结构问题

---

## 难度分布
- 🟢 简单题：题目1（验证BST）、题目3（数组转BST）
- 🟡 中等题：题目2（第K小元素）、题目4（范围和）
- 🔴 困难题：题目5（恢复BST）

## 核心知识点
1. **BST基本性质**：有序性、搜索效率
2. **中序遍历应用**：有序输出、查找第K小、验证有效性
3. **递归构造**：分治思想、平衡性保证
4. **范围查询优化**：剪枝搜索、性能提升
5. **错误检测修复**：异常识别、原地修复

## 解题策略提示
1. **充分利用BST性质**：每道题都要考虑如何利用BST的有序性
2. **递归边界处理**：注意空节点和边界条件的处理
3. **空间优化考虑**：优先使用迭代方法或尾递归优化
4. **测试用例设计**：考虑空树、单节点、完全不平衡等特殊情况 