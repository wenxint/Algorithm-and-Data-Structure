# 第18章 单调栈 - README

## 单调栈算法概述

单调栈（Monotonic Stack）是一种特殊的栈数据结构，其内部元素始终保持着严格的单调性（递增或递减）。这种特性使得单调栈在解决特定类型的问题时具有极高的效率，通常能够将O(n²)时间复杂度的问题优化为O(n)。

## 基础方法

### 1. 单调栈的基本操作

单调栈的核心操作包括：
- **入栈**：在保持栈单调性的前提下，将元素入栈
- **出栈**：当新元素破坏栈的单调性时，弹出栈顶元素
- **维护**：通过入栈和出栈操作维持栈的单调性
- **查询**：获取栈顶元素或其他特定位置的元素

### 2. 单调栈的实现模板

#### 2.1 单调递增栈模板

```javascript
/**
 * 单调递增栈模板
 * @param {number[]} nums - 输入数组
 * @return {number[]} - 结果数组
 */
function monotonicIncreasingStack(nums) {
    const stack = [];
    const result = new Array(nums.length).fill(-1);
    
    for (let i = 0; i < nums.length; i++) {
        // 当前元素小于栈顶元素，保持递增性，直接入栈
        // 当前元素大于栈顶元素，破坏递增性，弹出栈顶元素
        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {
            const topIndex = stack.pop();
            // 对弹出的元素进行处理
            result[topIndex] = i; // 记录下一个更大元素的索引
        }
        stack.push(i);
    }
    
    return result;
}
```

#### 2.2 单调递减栈模板

```javascript
/**
 * 单调递减栈模板
 * @param {number[]} nums - 输入数组
 * @return {number[]} - 结果数组
 */
function monotonicDecreasingStack(nums) {
    const stack = [];
    const result = new Array(nums.length).fill(-1);
    
    for (let i = 0; i < nums.length; i++) {
        // 当前元素大于栈顶元素，保持递减性，直接入栈
        // 当前元素小于栈顶元素，破坏递减性，弹出栈顶元素
        while (stack.length > 0 && nums[i] < nums[stack[stack.length - 1]]) {
            const topIndex = stack.pop();
            // 对弹出的元素进行处理
            result[topIndex] = i; // 记录下一个更小元素的索引
        }
        stack.push(i);
    }
    
    return result;
}
```

## 核心算法思想

### 1. 单调性维护

单调栈的核心在于维护栈内元素的单调性。当新元素入栈时，如果破坏了栈的单调性，则需要弹出栈顶元素，直到栈恢复单调性为止。这个过程中，每个元素只会入栈和出栈一次，保证了算法的高效性。

### 2. 问题转化

单调栈擅长将复杂的问题转化为对元素间关系的直观判断。例如：
- 将「最大矩形面积」问题转化为寻找每个柱子的左右边界
- 将「接雨水」问题转化为寻找每个位置的左右最大高度
- 将「下一个更大元素」问题转化为栈内元素的比较

### 3. 空间换时间

单调栈通过使用额外的栈空间，将原本需要嵌套循环的O(n²)时间复杂度优化为O(n)，是典型的空间换时间策略。

## 单调栈与其他数据结构的关系

### 1. 单调栈与普通栈

- **相同点**：都遵循先进后出（LIFO）的原则
- **不同点**：单调栈在入栈时会额外执行维护单调性的操作

### 2. 单调栈与优先队列

- **相同点**：都能高效地获取最大/最小值
- **不同点**：单调栈主要用于解决序列中的相邻关系问题，而优先队列适用于动态元素的排序

### 3. 单调栈与双指针

- **相同点**：都能优化嵌套循环，降低时间复杂度
- **不同点**：单调栈通过栈维护元素关系，双指针通过两个指针控制区间

## 典型应用场景

单调栈在以下场景中表现出色：

1. **下一个元素系列问题**
   - 下一个更大元素
   - 下一个更小元素
   - 每日温度问题

2. **矩形面积问题**
   - 柱状图中最大的矩形
   - 最大矩形面积

3. **区间极值问题**
   - 滑动窗口最大值
   - 子数组的最小值之和

4. **字符串处理问题**
   - 去除重复字母
   - 最长有效括号

## 复杂度分析

- **时间复杂度**：O(n)，每个元素最多入栈和出栈一次
- **空间复杂度**：O(n)，最坏情况下需要存储所有元素

## 使用建议

1. **选择合适的单调性**：
   - 寻找「下一个更大元素」使用单调递减栈
   - 寻找「下一个更小元素」使用单调递增栈

2. **存储索引而非值**：通常存储元素索引，便于计算距离和获取其他属性

3. **处理边界条件**：在数组首尾添加哨兵元素，简化边界处理

4. **结合哈希表**：对于需要快速查找的数据，结合哈希表提高效率

## 学习资源

- LeetCode专题：单调栈
- 《算法竞赛进阶指南》
- 《编程珠玑》
- 极客时间：《数据结构与算法之美》