# 第15章：回溯算法 - 练习题

本章包含5道精选的回溯算法练习题，涵盖不同难度和应用场景。

## 练习题目录

| 题目 | 难度 | 核心技巧 | 时间复杂度 |
|------|------|----------|------------|
| [1. 单词搜索](#1-单词搜索) | 中等 | 二维网格回溯 | O(m×n×4^L) |
| [2. 分割回文串](#2-分割回文串) | 中等 | 字符串分割回溯 | O(n×2^n) |
| [3. 组合总和](#3-组合总和) | 中等 | 数组组合回溯 | O(2^n) |
| [4. 恢复IP地址](#4-恢复IP地址) | 中等 | 约束条件回溯 | O(3^4) |
| [5. 解数独](#5-解数独) | 困难 | 约束满足问题 | O(9^(81-filled)) |

---

## 1. 单词搜索

### 问题描述
给定一个 m×n 的二维字符网格 `board` 和一个字符串单词 `word`，如果 `word` 存在于网格中，返回 `true`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

### 核心思想
- **回溯策略**：从每个可能的起点开始深度优先搜索
- **状态管理**：使用 `visited` 数组记录已访问的单元格
- **路径探索**：在四个方向上递归搜索下一个字符
- **回溯恢复**：搜索失败时恢复 `visited` 状态

### 示例
```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

### 实现要求
1. 实现基础的单词搜索功能
2. 优化搜索策略，避免不必要的搜索
3. 实现多单词搜索的扩展版本

### 关键知识点
- 二维网格的 DFS 遍历
- 回溯算法的状态恢复
- 边界条件检查
- 搜索剪枝优化

---

## 2. 分割回文串

### 问题描述
给定一个字符串 `s`，将 `s` 分割成一些子串，使得每个子串都是回文串。返回 `s` 所有可能的分割方案。

### 核心思想
- **分割策略**：从每个位置尝试分割，检查前缀是否为回文
- **回溯框架**：递归处理剩余的子字符串
- **回文判断**：提前计算所有子串的回文性质以优化性能
- **解的构建**：逐步构建完整的分割方案

### 示例
```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]

输入：s = "raceacar"
输出：[["r","a","c","e","a","c","a","r"],["r","a","ce","c","a","r"],["r","ac","e","a","car"],["r","ace","a","car"],["race","a","car"]]

输入：s = "a"
输出：[["a"]]
```

### 实现要求
1. 实现基础的回文分割功能
2. 使用动态规划预处理回文判断
3. 统计所有分割方案的数量（不返回具体方案）

### 关键知识点
- 字符串分割的回溯策略
- 回文串的高效判断
- 动态规划优化
- 路径记录和状态管理

---

## 3. 组合总和

### 问题描述
给定一个无重复元素的正整数数组 `candidates` 和一个正整数 `target`，找出 `candidates` 中所有可以使数字和为目标数 `target` 的唯一组合。

`candidates` 中的数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是唯一的。

### 核心思想
- **选择策略**：对于每个数字，选择包含或不包含
- **重复使用**：允许重复选择同一个数字
- **剪枝优化**：当前和超过目标值时提前退出
- **去重处理**：确保组合的唯一性

### 示例
```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]

输入：candidates = [2,3,5], target = 8
输出：[[2,2,2,2],[2,3,3],[3,5]]

输入：candidates = [2], target = 1
输出：[]
```

### 实现要求
1. 实现基础的组合总和功能
2. 扩展到包含重复数字的情况
3. 实现限制每个数字使用次数的版本

### 关键知识点
- 组合问题的回溯模板
- 数组元素的重复使用策略
- 排序优化和剪枝技巧
- 去重算法的实现

---

## 4. 恢复IP地址

### 问题描述
给定一个只包含数字的字符串 `s`，用以表示一个IP地址，返回所有可能从 `s` 获得的有效IP地址。你可以按任何顺序返回答案。

有效IP地址正好由四个整数（每个整数位于 0 到 255 之间构成，且不能含有前导 0），整数之间用 '.' 分隔。

### 核心思想
- **分段策略**：将字符串分成四段，每段对应IP地址的一部分
- **约束检查**：每段必须是0-255之间的有效数字
- **前导零处理**：除了"0"本身，不允许前导零
- **长度限制**：每段长度为1-3个字符

### 示例
```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]

输入：s = "0000"
输出：["0.0.0.0"]

输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

### 实现要求
1. 实现基础的IP地址恢复功能
2. 处理边界情况（如前导零、超出范围等）
3. 优化算法减少不必要的分支探索

### 关键知识点
- 字符串分段的回溯策略
- 数字范围和格式的约束检查
- 前导零的特殊处理
- 分支数量的优化控制

---

## 5. 解数独

### 问题描述
编写一个程序，通过填充空格来解决数独问题。

数独的解法需遵循如下规则：
1. 数字 1-9 在每一行只能出现一次
2. 数字 1-9 在每一列只能出现一次  
3. 数字 1-9 在每一个以粗实线分隔的 3×3 宫格内只能出现一次

空白格用 '.' 表示。

### 核心思想
- **约束传播**：同时满足行、列、宫格三种约束
- **最小剩余值**：优先填充候选数字最少的格子
- **前向检查**：填入数字后立即更新相关约束
- **智能回溯**：约束冲突时高效回溯到上一个决策点

### 示例
```
输入：board = 
[["5","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 [".","9","8",".",".",".",".","6","."],
 ["8",".",".",".","6",".",".",".","3"],
 ["4",".",".","8",".","3",".",".","1"],
 ["7",".",".",".","2",".",".",".","6"],
 [".","6",".",".",".",".","2","8","."],
 [".",".",".","4","1","9",".",".","5"],
 [".",".",".",".","8",".",".","7","9"]]

输出：
[["5","3","4","6","7","8","9","1","2"],
 ["6","7","2","1","9","5","3","4","8"],
 ["1","9","8","3","4","2","5","6","7"],
 ["8","5","9","7","6","1","4","2","3"],
 ["4","2","6","8","5","3","7","9","1"],
 ["7","1","3","9","2","4","8","5","6"],
 ["9","6","1","5","3","7","2","8","4"],
 ["2","8","7","4","1","9","6","3","5"],
 ["3","4","5","2","8","6","1","7","9"]]
```

### 实现要求
1. 实现基础的数独解决功能
2. 使用启发式算法优化搜索效率
3. 扩展到检查数独是否有唯一解

### 关键知识点
- 约束满足问题的建模
- 多重约束的高效检查
- 启发式搜索策略
- 回溯算法的性能优化

---

## 总结

| 题目 | 难度 | 核心算法思想 | 优化技巧 |
|------|------|--------------|----------|
| 单词搜索 | 中等 | 二维DFS回溯 | 方向数组，状态恢复 |
| 分割回文串 | 中等 | 字符串分割回溯 | DP预处理回文 |
| 组合总和 | 中等 | 组合选择回溯 | 排序剪枝，去重 |
| 恢复IP地址 | 中等 | 分段约束回溯 | 长度和范围检查 |
| 解数独 | 困难 | 约束满足回溯 | 启发式搜索，前向检查 |

这些练习题涵盖了回溯算法的主要应用场景，从简单的路径搜索到复杂的约束满足问题，帮助巩固和深化对回溯算法的理解。 