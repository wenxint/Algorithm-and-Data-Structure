# æ•°ç»„è½¬æ ‘ç»“æ„é—®é¢˜ ğŸŒ³

## ğŸ¯ é¢˜ç›®æè¿°
ç»™å®šä¸€ä¸ªè¡¨ç¤ºæ ‘ç»“æ„å…³ç³»çš„æ•°ç»„ï¼Œå°†å…¶è½¬æ¢ä¸ºåµŒå¥—çš„æ ‘å½¢ç»“æ„ã€‚æ¯ä¸ªèŠ‚ç‚¹åŒ…å« idã€parentId å’Œå…¶ä»–å±æ€§ã€‚

**è¦æ±‚**ï¼š
- è¾“å…¥æ˜¯ä¸€ä¸ªæ‰å¹³çš„æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å« id å’Œ parentId
- æ ¹èŠ‚ç‚¹çš„ parentId ä¸º null æˆ– 0
- è¾“å‡ºåµŒå¥—çš„æ ‘å½¢ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å« children æ•°ç»„
- ä¿æŒåŸæœ‰å±æ€§ä¸å˜

**ç¤ºä¾‹**ï¼š
```javascript
// è¾“å…¥
const flatArray = [
    { id: 1, name: 'æ ¹èŠ‚ç‚¹', parentId: null },
    { id: 2, name: 'å­èŠ‚ç‚¹1', parentId: 1 },
    { id: 3, name: 'å­èŠ‚ç‚¹2', parentId: 1 },
    { id: 4, name: 'å­™èŠ‚ç‚¹1', parentId: 2 },
    { id: 5, name: 'å­™èŠ‚ç‚¹2', parentId: 3 }
];

// è¾“å‡º
[
    {
        id: 1,
        name: 'æ ¹èŠ‚ç‚¹',
        parentId: null,
        children: [
            {
                id: 2,
                name: 'å­èŠ‚ç‚¹1',
                parentId: 1,
                children: [
                    { id: 4, name: 'å­™èŠ‚ç‚¹1', parentId: 2, children: [] }
                ]
            },
            {
                id: 3,
                name: 'å­èŠ‚ç‚¹2',
                parentId: 1,
                children: [
                    { id: 5, name: 'å­™èŠ‚ç‚¹2', parentId: 3, children: [] }
                ]
            }
        ]
    }
]
```

## ğŸ’¡ æˆ‘çš„åŸå§‹æ–¹æ³•

### æ€è·¯åˆ†æ
æˆ‘æœ€å¼€å§‹çš„æƒ³æ³•æ˜¯ï¼š
1. é€’å½’åœ°ä¸ºæ¯ä¸ªèŠ‚ç‚¹æŸ¥æ‰¾å®ƒçš„å­èŠ‚ç‚¹
2. å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œéå†æ•´ä¸ªæ•°ç»„æ‰¾åˆ°å…¶å­èŠ‚ç‚¹
3. ç„¶åé€’å½’å¤„ç†æ¯ä¸ªå­èŠ‚ç‚¹

### ä»£ç å®ç°
```javascript
function buildTree(flatArray) {
    // æ‰¾åˆ°æ ¹èŠ‚ç‚¹
    const roots = flatArray.filter(item => !item.parentId || item.parentId === 0);

    // é€’å½’æ„å»ºæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„æ ‘
    function buildNode(node) {
        const children = flatArray.filter(item => item.parentId === node.id);

        if (children.length > 0) {
            node.children = children.map(child => buildNode({...child}));
        } else {
            node.children = [];
        }

        return node;
    }

    return roots.map(root => buildNode({...root}));
}

// æµ‹è¯•
const flatArray = [
    { id: 1, name: 'æ ¹èŠ‚ç‚¹', parentId: null },
    { id: 2, name: 'å­èŠ‚ç‚¹1', parentId: 1 },
    { id: 3, name: 'å­èŠ‚ç‚¹2', parentId: 1 },
    { id: 4, name: 'å­™èŠ‚ç‚¹1', parentId: 2 }
];

console.log(JSON.stringify(buildTree(flatArray), null, 2));
```

### å­˜åœ¨çš„é—®é¢˜
- âŒ æ—¶é—´å¤æ‚åº¦è¿‡é«˜ O(nÂ²)ï¼Œæ¯æ¬¡éƒ½è¦éå†æ•´ä¸ªæ•°ç»„
- âŒ æ²¡æœ‰è¾“å…¥éªŒè¯
- âŒ æ²¡æœ‰å¤„ç†å¾ªç¯å¼•ç”¨ç­‰å¼‚å¸¸æƒ…å†µ
- âŒ ä»£ç ç»“æ„ä¸å¤Ÿæ¸…æ™°

## ğŸ”§ æ”¹è¿›ç‰ˆæœ¬

### ä¼˜åŒ–æ€è·¯
1. ä½¿ç”¨ Map ä¼˜åŒ–æŸ¥æ‰¾æ€§èƒ½ï¼Œä» O(nÂ²) é™åˆ° O(n)
2. æ·»åŠ è¾“å…¥éªŒè¯å’Œå¼‚å¸¸å¤„ç†
3. å¢åŠ å¾ªç¯å¼•ç”¨æ£€æµ‹
4. ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼Œé¿å…ä¸å¿…è¦çš„å¤åˆ¶

### æ”¹è¿›ä»£ç 
```javascript
/**
 * æ•°ç»„è½¬æ ‘ç»“æ„ç®—æ³•ï¼ˆæ”¹è¿›ç‰ˆï¼‰
 *
 * æ ¸å¿ƒæ€æƒ³ï¼š
 * 1. ä½¿ç”¨ Map å»ºç«‹ id åˆ°èŠ‚ç‚¹çš„å¿«é€ŸæŸ¥æ‰¾
 * 2. ä¸€æ¬¡éå†å»ºç«‹çˆ¶å­å…³ç³»
 * 3. é¿å…é€’å½’ï¼Œä½¿ç”¨è¿­ä»£æ–¹å¼æé«˜æ€§èƒ½
 *
 * @param {Array} flatArray - æ‰å¹³æ•°ç»„
 * @param {Object} options - é…ç½®é€‰é¡¹
 * @returns {Array} æ ‘å½¢ç»“æ„æ•°ç»„
 * @time O(n) çº¿æ€§æ—¶é—´å¤æ‚åº¦
 * @space O(n) ä¸»è¦æ˜¯Mapå’Œç»“æœçš„ç©ºé—´
 */
function buildTreeImproved(flatArray, options = {}) {
    // é…ç½®é€‰é¡¹
    const {
        idKey = 'id',
        parentIdKey = 'parentId',
        childrenKey = 'children',
        rootValue = null,
        validateCircular = true,
        preserveOriginal = true
    } = options;

    // è¾“å…¥éªŒè¯
    if (!Array.isArray(flatArray)) {
        throw new Error('è¾“å…¥å¿…é¡»æ˜¯æ•°ç»„');
    }

    if (flatArray.length === 0) {
        return [];
    }

    console.log(`å¼€å§‹å¤„ç† ${flatArray.length} ä¸ªèŠ‚ç‚¹`);

    // éªŒè¯å¿…è¦å­—æ®µ
    for (let i = 0; i < flatArray.length; i++) {
        const item = flatArray[i];
        if (!item.hasOwnProperty(idKey)) {
            throw new Error(`ç¬¬ ${i} ä¸ªèŠ‚ç‚¹ç¼ºå°‘ ${idKey} å­—æ®µ`);
        }
    }

    // æ·±åº¦å¤åˆ¶æ•°æ®ï¼ˆå¦‚æœéœ€è¦ä¿æŒåŸæ•°æ®ä¸å˜ï¼‰
    const nodes = preserveOriginal
        ? flatArray.map(item => ({ ...item, [childrenKey]: [] }))
        : flatArray.map(item => ({ ...item, [childrenKey]: [] }));

    // å»ºç«‹ id åˆ°èŠ‚ç‚¹çš„æ˜ å°„
    const nodeMap = new Map();
    const rootNodes = [];

    // ç¬¬ä¸€æ¬¡éå†ï¼šå»ºç«‹æ˜ å°„å¹¶æ”¶é›†æ ¹èŠ‚ç‚¹
    for (const node of nodes) {
        const id = node[idKey];

        // æ£€æŸ¥é‡å¤ID
        if (nodeMap.has(id)) {
            throw new Error(`å‘ç°é‡å¤çš„ ${idKey}: ${id}`);
        }

        nodeMap.set(id, node);

        // åˆ¤æ–­æ˜¯å¦ä¸ºæ ¹èŠ‚ç‚¹
        const parentId = node[parentIdKey];
        if (parentId === rootValue || parentId === 0 || parentId === undefined) {
            rootNodes.push(node);
            console.log(`æ‰¾åˆ°æ ¹èŠ‚ç‚¹: ${id}`);
        }
    }

    console.log(`æ‰¾åˆ° ${rootNodes.length} ä¸ªæ ¹èŠ‚ç‚¹`);

    // å¾ªç¯å¼•ç”¨æ£€æµ‹ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (validateCircular) {
        console.log('å¼€å§‹å¾ªç¯å¼•ç”¨æ£€æµ‹...');
        detectCircularReference(nodes, idKey, parentIdKey, nodeMap);
        console.log('å¾ªç¯å¼•ç”¨æ£€æµ‹å®Œæˆ');
    }

    // ç¬¬äºŒæ¬¡éå†ï¼šå»ºç«‹çˆ¶å­å…³ç³»
    let orphanCount = 0;
    for (const node of nodes) {
        const parentId = node[parentIdKey];

        // è·³è¿‡æ ¹èŠ‚ç‚¹
        if (parentId === rootValue || parentId === 0 || parentId === undefined) {
            continue;
        }

        const parentNode = nodeMap.get(parentId);
        if (parentNode) {
            parentNode[childrenKey].push(node);
            console.log(`èŠ‚ç‚¹ ${node[idKey]} æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹ ${parentId}`);
        } else {
            orphanCount++;
            console.warn(`è­¦å‘Š: èŠ‚ç‚¹ ${node[idKey]} çš„çˆ¶èŠ‚ç‚¹ ${parentId} ä¸å­˜åœ¨ï¼Œå°†æˆä¸ºå­¤å„¿èŠ‚ç‚¹`);
        }
    }

    if (orphanCount > 0) {
        console.warn(`å‘ç° ${orphanCount} ä¸ªå­¤å„¿èŠ‚ç‚¹`);
    }

    // ç»Ÿè®¡ä¿¡æ¯
    const stats = calculateTreeStats(rootNodes, childrenKey);
    console.log('æ ‘æ„å»ºå®Œæˆï¼š', stats);

    return rootNodes;
}

/**
 * å¾ªç¯å¼•ç”¨æ£€æµ‹
 */
function detectCircularReference(nodes, idKey, parentIdKey, nodeMap) {
    const visiting = new Set();
    const visited = new Set();

    function dfs(nodeId) {
        if (visiting.has(nodeId)) {
            throw new Error(`æ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨ï¼ŒèŠ‚ç‚¹ ${nodeId} å½¢æˆç¯`);
        }

        if (visited.has(nodeId)) {
            return; // å·²ç»æ£€æŸ¥è¿‡
        }

        visiting.add(nodeId);

        const node = nodeMap.get(nodeId);
        if (node && node[parentIdKey]) {
            dfs(node[parentIdKey]);
        }

        visiting.delete(nodeId);
        visited.add(nodeId);
    }

    for (const node of nodes) {
        if (!visited.has(node[idKey])) {
            dfs(node[idKey]);
        }
    }
}

/**
 * è®¡ç®—æ ‘çš„ç»Ÿè®¡ä¿¡æ¯
 */
function calculateTreeStats(roots, childrenKey) {
    let totalNodes = 0;
    let maxDepth = 0;

    function traverse(nodes, depth = 0) {
        maxDepth = Math.max(maxDepth, depth);

        for (const node of nodes) {
            totalNodes++;
            if (node[childrenKey] && node[childrenKey].length > 0) {
                traverse(node[childrenKey], depth + 1);
            }
        }
    }

    traverse(roots);

    return {
        rootCount: roots.length,
        totalNodes,
        maxDepth
    };
}

// å®Œæ•´æµ‹è¯•å‡½æ•°
function testTreeBuilding() {
    const testCases = [
        {
            input: [],
            expected: [],
            description: "ç©ºæ•°ç»„"
        },
        {
            input: [{ id: 1, name: 'å•èŠ‚ç‚¹', parentId: null }],
            expected: [{ id: 1, name: 'å•èŠ‚ç‚¹', parentId: null, children: [] }],
            description: "å•ä¸ªæ ¹èŠ‚ç‚¹"
        },
        {
            input: [
                { id: 1, name: 'æ ¹èŠ‚ç‚¹', parentId: null },
                { id: 2, name: 'å­èŠ‚ç‚¹1', parentId: 1 },
                { id: 3, name: 'å­èŠ‚ç‚¹2', parentId: 1 }
            ],
            expected: [{
                id: 1, name: 'æ ¹èŠ‚ç‚¹', parentId: null,
                children: [
                    { id: 2, name: 'å­èŠ‚ç‚¹1', parentId: 1, children: [] },
                    { id: 3, name: 'å­èŠ‚ç‚¹2', parentId: 1, children: [] }
                ]
            }],
            description: "åŸºæœ¬çˆ¶å­å…³ç³»"
        },
        {
            input: [
                { id: 1, name: 'æ ¹1', parentId: null },
                { id: 2, name: 'æ ¹2', parentId: null },
                { id: 3, name: 'å­1', parentId: 1 },
                { id: 4, name: 'å­2', parentId: 2 }
            ],
            expected: [
                { id: 1, name: 'æ ¹1', parentId: null, children: [{ id: 3, name: 'å­1', parentId: 1, children: [] }] },
                { id: 2, name: 'æ ¹2', parentId: null, children: [{ id: 4, name: 'å­2', parentId: 2, children: [] }] }
            ],
            description: "å¤šä¸ªæ ¹èŠ‚ç‚¹"
        }
    ];

    testCases.forEach((testCase, index) => {
        console.log(`\n=== æµ‹è¯•ç”¨ä¾‹ ${index + 1}: ${testCase.description} ===`);

        try {
            const result = buildTreeImproved(testCase.input);
            console.log('è¾“å…¥:', JSON.stringify(testCase.input));
            console.log('è¾“å‡º:', JSON.stringify(result, null, 2));
            console.log('âœ… æµ‹è¯•é€šè¿‡');
        } catch (error) {
            console.error('âŒ æµ‹è¯•å¤±è´¥:', error.message);
        }
    });
}

testTreeBuilding();
```

### æ”¹è¿›äº®ç‚¹
- âœ… æ—¶é—´å¤æ‚åº¦ä» O(nÂ²) é™åˆ° O(n)
- âœ… æ·»åŠ äº†å®Œæ•´çš„è¾“å…¥éªŒè¯å’Œå¼‚å¸¸å¤„ç†
- âœ… æ”¯æŒå¾ªç¯å¼•ç”¨æ£€æµ‹
- âœ… æä¾›äº†è¯¦ç»†çš„ç»Ÿè®¡ä¿¡æ¯å’Œé…ç½®é€‰é¡¹

## ğŸŒŸ æ¨èçš„æœ€ä½³æ–¹æ³•

### æ–¹æ³•ä¸€ï¼šMapä¼˜åŒ–ç‰ˆï¼ˆæ¨èï¼‰
```javascript
/**
 * æ•°ç»„è½¬æ ‘ç»“æ„ - Mapä¼˜åŒ–ç‰ˆ
 *
 * æœ€é«˜æ•ˆå’Œå®ç”¨çš„ç‰ˆæœ¬ï¼Œé€‚åˆç”Ÿäº§ç¯å¢ƒ
 *
 * @param {Array} flatArray - æ‰å¹³æ•°ç»„
 * @param {string} idKey - IDå­—æ®µå
 * @param {string} parentIdKey - çˆ¶IDå­—æ®µå
 * @returns {Array} æ ‘å½¢ç»“æ„
 */
function arrayToTree(flatArray, idKey = 'id', parentIdKey = 'parentId') {
    if (!flatArray.length) return [];

    const map = new Map();
    const roots = [];

    // åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹
    flatArray.forEach(item => {
        map.set(item[idKey], { ...item, children: [] });
    });

    // å»ºç«‹çˆ¶å­å…³ç³»
    flatArray.forEach(item => {
        const node = map.get(item[idKey]);
        const parentId = item[parentIdKey];

        if (parentId && map.has(parentId)) {
            map.get(parentId).children.push(node);
        } else {
            roots.push(node);
        }
    });

    return roots;
}
```

### æ–¹æ³•äºŒï¼šé€’å½’ä¼˜åŒ–ç‰ˆ
```javascript
/**
 * æ•°ç»„è½¬æ ‘ç»“æ„ - é€’å½’ä¼˜åŒ–ç‰ˆ
 *
 * ä½¿ç”¨Mapç¼“å­˜æé«˜é€’å½’æ•ˆç‡
 *
 * @param {Array} flatArray - æ‰å¹³æ•°ç»„
 * @returns {Array} æ ‘å½¢ç»“æ„
 */
function arrayToTreeRecursive(flatArray) {
    const map = new Map();

    // å»ºç«‹æŸ¥æ‰¾æ˜ å°„
    flatArray.forEach(item => {
        if (!map.has(item.parentId)) {
            map.set(item.parentId, []);
        }
        map.get(item.parentId).push(item);
    });

    function buildTree(parentId = null) {
        const children = map.get(parentId) || [];
        return children.map(child => ({
            ...child,
            children: buildTree(child.id)
        }));
    }

    return buildTree();
}
```

### æ–¹æ³•ä¸‰ï¼šå‡½æ•°å¼ç¼–ç¨‹ç‰ˆ
```javascript
/**
 * æ•°ç»„è½¬æ ‘ç»“æ„ - å‡½æ•°å¼ç‰ˆæœ¬
 *
 * ä½¿ç”¨ reduce å’Œ filter çš„å‡½æ•°å¼é£æ ¼
 *
 * @param {Array} flatArray - æ‰å¹³æ•°ç»„
 * @returns {Array} æ ‘å½¢ç»“æ„
 */
function arrayToTreeFunctional(flatArray) {
    const nodeMap = flatArray.reduce((map, node) => {
        map[node.id] = { ...node, children: [] };
        return map;
    }, {});

    return flatArray.reduce((roots, node) => {
        if (node.parentId && nodeMap[node.parentId]) {
            nodeMap[node.parentId].children.push(nodeMap[node.id]);
        } else {
            roots.push(nodeMap[node.id]);
        }
        return roots;
    }, []);
}
```

### é€šç”¨æ ‘ç»“æ„å·¥å…·ç±»
```javascript
/**
 * æ ‘ç»“æ„å·¥å…·ç±»
 *
 * æä¾›æ ‘ç»“æ„çš„å„ç§æ“ä½œæ–¹æ³•
 */
class TreeUtils {
    /**
     * æ•°ç»„è½¬æ ‘ç»“æ„
     */
    static arrayToTree(flatArray, config = {}) {
        const {
            idKey = 'id',
            parentIdKey = 'parentId',
            childrenKey = 'children',
            rootParentId = null
        } = config;

        const map = new Map();
        const roots = [];

        // åˆå§‹åŒ–æ˜ å°„
        flatArray.forEach(item => {
            map.set(item[idKey], { ...item, [childrenKey]: [] });
        });

        // å»ºç«‹å…³ç³»
        flatArray.forEach(item => {
            const node = map.get(item[idKey]);
            const parentId = item[parentIdKey];

            if (parentId !== rootParentId && map.has(parentId)) {
                map.get(parentId)[childrenKey].push(node);
            } else {
                roots.push(node);
            }
        });

        return roots;
    }

    /**
     * æ ‘ç»“æ„è½¬æ•°ç»„
     */
    static treeToArray(treeArray, childrenKey = 'children') {
        const result = [];

        function traverse(nodes) {
            nodes.forEach(node => {
                const { [childrenKey]: children, ...nodeData } = node;
                result.push(nodeData);

                if (children && children.length > 0) {
                    traverse(children);
                }
            });
        }

        traverse(treeArray);
        return result;
    }

    /**
     * æŸ¥æ‰¾èŠ‚ç‚¹
     */
    static findNode(treeArray, predicate, childrenKey = 'children') {
        for (const node of treeArray) {
            if (predicate(node)) {
                return node;
            }

            if (node[childrenKey]) {
                const found = this.findNode(node[childrenKey], predicate, childrenKey);
                if (found) return found;
            }
        }
        return null;
    }

    /**
     * è¿‡æ»¤æ ‘èŠ‚ç‚¹
     */
    static filterTree(treeArray, predicate, childrenKey = 'children') {
        return treeArray.reduce((filtered, node) => {
            const newNode = { ...node };

            if (node[childrenKey]) {
                newNode[childrenKey] = this.filterTree(node[childrenKey], predicate, childrenKey);
            }

            if (predicate(newNode) || (newNode[childrenKey] && newNode[childrenKey].length > 0)) {
                filtered.push(newNode);
            }

            return filtered;
        }, []);
    }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|------|------|----------|
| æˆ‘çš„åŸå§‹ç‰ˆæœ¬ | O(nÂ²) | O(n) | æ€è·¯ç›´è§‚ | æ•ˆç‡ä½ä¸‹ | å­¦ä¹ ç†è§£ |
| Mapä¼˜åŒ–ç‰ˆ | O(n) | O(n) | é«˜æ•ˆå®ç”¨ | ä»£ç ç¨å¤æ‚ | ç”Ÿäº§æ¨è |
| é€’å½’ä¼˜åŒ–ç‰ˆ | O(n) | O(h) | é€»è¾‘æ¸…æ™° | å¯èƒ½æ ˆæº¢å‡º | ä¸­ç­‰æ•°æ®é‡ |
| å‡½æ•°å¼ç‰ˆæœ¬ | O(n) | O(n) | ä»£ç ä¼˜é›… | ç†è§£é—¨æ§› | å‡½æ•°å¼é¡¹ç›® |
| å·¥å…·ç±»ç‰ˆæœ¬ | O(n) | O(n) | åŠŸèƒ½å…¨é¢ | ä»£ç é‡å¤§ | å¤æ‚åº”ç”¨ |

## ğŸ“ çŸ¥è¯†ç‚¹æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ
1. **æ•°æ®ç»“æ„è½¬æ¢**ï¼šæ‰å¹³ç»“æ„ä¸å±‚æ¬¡ç»“æ„çš„ç›¸äº’è½¬æ¢
2. **Mapä¼˜åŒ–æŸ¥æ‰¾**ï¼šä½¿ç”¨å“ˆå¸Œè¡¨æé«˜æŸ¥æ‰¾æ•ˆç‡
3. **å¼•ç”¨å…³ç³»å»ºç«‹**ï¼šæ­£ç¡®å¤„ç†å¯¹è±¡å¼•ç”¨é¿å…å¾ªç¯
4. **å¼‚å¸¸æƒ…å†µå¤„ç†**ï¼šå­¤å„¿èŠ‚ç‚¹ã€å¾ªç¯å¼•ç”¨ç­‰

### å…³é”®æŠ€å·§
- **ä¸¤æ¬¡éå†**ï¼šç¬¬ä¸€æ¬¡å»ºç«‹æ˜ å°„ï¼Œç¬¬äºŒæ¬¡å»ºç«‹å…³ç³»
- **å¼•ç”¨å¤ç”¨**ï¼šé¿å…ä¸å¿…è¦çš„å¯¹è±¡å¤åˆ¶
- **å¼‚å¸¸æ£€æµ‹**ï¼šå¾ªç¯å¼•ç”¨å’Œå­¤å„¿èŠ‚ç‚¹å¤„ç†
- **é…ç½®çµæ´»æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰å­—æ®µåå’Œé€‰é¡¹

### å®é™…åº”ç”¨
1. **ç»„ç»‡æ¶æ„**ï¼šå…¬å¸éƒ¨é—¨å±‚çº§ç»“æ„
2. **èœå•ç³»ç»Ÿ**ï¼šå¤šçº§å¯¼èˆªèœå•
3. **è¯„è®ºå›å¤**ï¼šè¯„è®ºå’Œå›å¤çš„åµŒå¥—ç»“æ„
4. **æ–‡ä»¶ç³»ç»Ÿ**ï¼šæ–‡ä»¶å¤¹å’Œæ–‡ä»¶çš„æ ‘å½¢ç»“æ„

## ğŸš¨ å¸¸è§é™·é˜±

### å¾ªç¯å¼•ç”¨
```javascript
// âŒ å±é™©ï¼šå¯èƒ½å­˜åœ¨å¾ªç¯å¼•ç”¨
const data = [
    { id: 1, parentId: 2 },
    { id: 2, parentId: 1 }
];

// âœ… æ­£ç¡®ï¼šæ£€æµ‹å¹¶å¤„ç†å¾ªç¯å¼•ç”¨
function hasCircularReference(data) {
    const visiting = new Set();
    // å®ç°å¾ªç¯æ£€æµ‹é€»è¾‘
}
```

### é‡å¤IDå¤„ç†
```javascript
// âŒ é”™è¯¯ï¼šæ²¡æœ‰æ£€æŸ¥é‡å¤ID
const map = new Map();
data.forEach(item => {
    map.set(item.id, item); // å¯èƒ½è¦†ç›–ç°æœ‰æ•°æ®
});

// âœ… æ­£ç¡®ï¼šæ£€æŸ¥é‡å¤ID
data.forEach(item => {
    if (map.has(item.id)) {
        throw new Error(`é‡å¤çš„ID: ${item.id}`);
    }
    map.set(item.id, item);
});
```

### å¼•ç”¨é—®é¢˜
```javascript
// âŒ é”™è¯¯ï¼šç›´æ¥ä¿®æ”¹åŸå§‹æ•°æ®
node.children = findChildren(node.id);

// âœ… æ­£ç¡®ï¼šåˆ›å»ºæ–°å¯¹è±¡é¿å…æ±¡æŸ“åŸæ•°æ®
const newNode = { ...node, children: findChildren(node.id) };
```

## ğŸ’­ å­¦ä¹ å¿ƒå¾—

### æˆ‘çš„æ”¶è·
1. **ç®—æ³•ä¼˜åŒ–çš„é‡è¦æ€§**ï¼šä» O(nÂ²) åˆ° O(n) çš„å·¨å¤§æå‡
2. **æ•°æ®ç»“æ„é€‰æ‹©**ï¼šMap æ¯” Array.find() æ•ˆç‡é«˜å¾—å¤š
3. **è¾¹ç•Œæƒ…å†µè€ƒè™‘**ï¼šå¾ªç¯å¼•ç”¨ã€å­¤å„¿èŠ‚ç‚¹ç­‰å¼‚å¸¸æƒ…å†µ
4. **ä»£ç å¥å£®æ€§**ï¼šå®Œå–„çš„éªŒè¯å’Œé”™è¯¯å¤„ç†

### è§£é¢˜æ¨¡æ¿
```javascript
function arrayToTree(flatArray) {
    // 1. è¾“å…¥éªŒè¯
    if (!Array.isArray(flatArray) || flatArray.length === 0) {
        return [];
    }

    // 2. å»ºç«‹æ˜ å°„
    const map = new Map();
    const roots = [];

    flatArray.forEach(item => {
        map.set(item.id, { ...item, children: [] });
    });

    // 3. å»ºç«‹å…³ç³»
    flatArray.forEach(item => {
        const node = map.get(item.id);
        if (item.parentId && map.has(item.parentId)) {
            map.get(item.parentId).children.push(node);
        } else {
            roots.push(node);
        }
    });

    return roots;
}
```

### é¢è¯•è¦ç‚¹
- ğŸ¯ **æ—¶é—´å¤æ‚åº¦**ï¼šè¯´æ˜O(n)è§£æ³•çš„ä¼˜åŠ¿
- ğŸ¯ **ç©ºé—´æƒè¡¡**ï¼šMapçš„ç©ºé—´æ¢æ—¶é—´ç­–ç•¥
- ğŸ¯ **å¼‚å¸¸å¤„ç†**ï¼šè€ƒè™‘å„ç§è¾¹ç•Œæƒ…å†µ
- ğŸ¯ **å®é™…åº”ç”¨**ï¼šè”ç³»å…·ä½“çš„ä¸šåŠ¡åœºæ™¯

### å®é™…åº”ç”¨
- ğŸ¢ **ä¼ä¸šç³»ç»Ÿ**ï¼šç»„ç»‡æ¶æ„ã€æƒé™æ ‘
- ğŸ® **å‰ç«¯å¼€å‘**ï¼šèœå•ç»„ä»¶ã€æ ‘å½¢é€‰æ‹©å™¨
- ğŸ“Š **æ•°æ®å¤„ç†**ï¼šåˆ†ç±»ç»Ÿè®¡ã€å±‚çº§æŠ¥è¡¨
- ğŸ”§ **ç³»ç»Ÿè®¾è®¡**ï¼šé…ç½®ç®¡ç†ã€ç›®å½•ç»“æ„

---
*å­¦ä¹ æ—¥æœŸï¼š2024å¹´ | éš¾åº¦ï¼šâ­â­â­â­â˜†*