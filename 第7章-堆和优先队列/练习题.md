# 第7章：堆和优先队列 - 练习题

本章重点学习堆和优先队列的核心算法思想和实际应用。通过以下5道精选题目，深入理解堆在解决Top-K问题、数据流处理、多路归并等场景中的优势。

---

## 题目1：数组中的第K个最大元素 ⭐⭐

### 题目描述
给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

### 核心思想
使用**最小堆**维护当前最大的K个元素：
- 堆的大小始终保持为K
- 堆顶元素就是第K大元素
- 时间复杂度：O(n log k)，空间复杂度：O(k)

### 示例
```
输入: nums = [3,2,1,5,6,4], k = 2
输出: 5

输入: nums = [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

### 要求
1. 实现基于最小堆的解法
2. 分析时间复杂度和空间复杂度
3. 对比直接排序的方法，说明堆方法的优势

### 学习要点
- 理解堆在Top-K问题中的应用
- 掌握最小堆和最大堆的使用场景
- 分析算法的时间和空间复杂度

---

## 题目2：数据流的中位数 ⭐⭐⭐

### 题目描述
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

设计一个支持以下两个操作的数据结构：
- `addNum(num)` - 从数据流中添加一个整数到数据结构中
- `findMedian()` - 返回目前所有元素的中位数

### 核心思想
使用**两个堆**维护数据流的中位数：
- **最大堆**：存储较小的一半数据
- **最小堆**：存储较大的一半数据
- 保持两个堆的大小平衡，中位数就在堆顶

### 示例
```
输入:
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]

输出: [null,null,null,1.5,null,2.0]
```

### 要求
1. 实现MedianFinder类
2. addNum操作的时间复杂度为O(log n)
3. findMedian操作的时间复杂度为O(1)
4. 处理数据流大小为奇数和偶数的情况

### 学习要点
- 理解双堆维护中位数的核心思想
- 掌握堆的平衡策略
- 学习动态维护数据流统计信息

---

## 题目3：合并K个升序链表 ⭐⭐⭐

### 题目描述
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

### 核心思想
使用**最小堆**进行多路归并：
- 将K个链表的头节点加入最小堆
- 每次提取堆顶最小节点，并将其下一个节点加入堆
- 重复直到所有节点都被处理

### 示例
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]

输入：lists = []
输出：[]

输入：lists = [[]]
输出：[]
```

### 要求
1. 使用最小堆实现多路归并
2. 时间复杂度：O(n log k)，其中n是所有节点总数
3. 空间复杂度：O(k)
4. 处理边界情况（空链表、空数组等）

### 学习要点
- 理解多路归并的核心思想
- 掌握堆在合并有序数据结构中的应用
- 学习链表操作和堆的结合使用

---

## 题目4：前K个高频元素 ⭐⭐⭐

### 题目描述
给你一个整数数组 `nums` 和一个整数 `k`，请你返回其中出现频率前 `k` 高的元素。你可以按任意顺序返回答案。

### 核心思想
结合**哈希表统计频率**和**最小堆选择Top-K**：
1. 使用哈希表统计每个元素的出现频率
2. 使用最小堆（按频率排序）维护前K个高频元素
3. 堆的大小保持为K，最终堆中就是答案

### 示例
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

输入: nums = [1], k = 1
输出: [1]
```

### 要求
1. 时间复杂度：O(n log k)
2. 空间复杂度：O(n)
3. 实现自定义比较函数的堆
4. 考虑k等于数组长度的边界情况

### 学习要点
- 理解频率统计与堆结合的算法模式
- 掌握自定义比较函数的堆实现
- 学习哈希表和堆的协同使用

---

## 题目5：会议室 II ⭐⭐⭐⭐

### 题目描述
给你一个会议时间安排的数组 `intervals`，每个会议时间都会包括开始和结束的时间 `[[s1,e1],[s2,e2],...]`，请你计算至少需要多少个会议室，才能满足这些会议安排。

### 核心思想
使用**最小堆**跟踪会议室使用情况：
1. 按会议开始时间排序
2. 用最小堆存储每个会议室的结束时间
3. 对于新会议，检查是否有会议室已结束可复用
4. 堆的大小就是所需的会议室数量

### 示例
```
输入：intervals = [[0,30],[5,10],[15,20]]
输出：2
解释：需要两个会议室
- 会议室1：[0,30]
- 会议室2：[5,10], [15,20]

输入：intervals = [[7,10],[2,4]]
输出：1
```

### 要求
1. 时间复杂度：O(n log n)
2. 空间复杂度：O(n)
3. 理解贪心策略的正确性
4. 处理会议时间重叠的各种情况

### 学习要点
- 理解堆在资源调度问题中的应用
- 掌握贪心算法与堆的结合
- 学习时间区间问题的经典解法

---

## 难度分布与学习重点

### 难度分布
- **简单题（1题）**：第K个最大元素 - 堆的基础应用
- **中等题（3题）**：数据流中位数、合并K个链表、前K个高频元素 - 堆的核心应用
- **困难题（1题）**：会议室调度 - 堆在复杂场景中的应用

### 核心知识点
1. **堆的基本操作**：插入、删除、查看堆顶
2. **Top-K问题**：使用堆的经典应用场景
3. **数据流处理**：动态维护数据结构状态
4. **多路归并**：堆在合并多个有序序列中的优势
5. **优先级调度**：堆在资源分配中的应用

### 解题策略
1. **识别Top-K类问题**：看到"第K大"、"前K个"等关键词
2. **选择合适的堆**：求大用小堆，求小用大堆
3. **考虑堆的大小**：通常维护大小为K的堆
4. **注意数据流场景**：考虑动态插入和查询的效率
5. **结合其他数据结构**：哈希表统计、数组排序等 