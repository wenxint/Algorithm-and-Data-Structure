<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
  /**
 * 堆排序
 * 
 * 核心思想：
 * 1. 建堆：将无序数组构造成最大堆，最大堆的特点是每个节点的值都大于或等于其子节点的值。
 * 2. 排序：反复提取堆顶（即数组的第一个元素）的最大元素，将其放到数组的末尾。
 * 3. 调整：每次提取堆顶元素后，重新调整堆结构，使其继续保持最大堆的性质。
 * 
 * @param {Array} arr 待排序数组，数组中的元素应为可比较大小的类型，如数字或字符串。
 * @returns {Array} 排序后的数组，原数组会被直接修改，返回的是排序后的原数组引用。
 * @time O(n log n) 所有情况，无论数组初始状态如何，堆排序的时间复杂度都是 O(n log n)。
 * @space O(1) 原地排序，只需要常数级的额外空间，不需要额外的数组来存储排序结果。
 */
function heapSort(arr) {
  // 获取数组的长度，后续建堆和排序过程会用到这个长度信息。
  const n = arr.length;

  // 建堆阶段：从最后一个非叶子节点开始，逐步向上调整每个节点，构建最大堆。
  // 最后一个非叶子节点的索引为 Math.floor(n / 2) - 1，因为叶子节点不需要调整。
  // 从这个节点开始，依次对每个非叶子节点调用 heapify 函数进行调整。
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    // 调用 heapify 函数，对以索引 i 为根节点的子树进行调整，使其满足最大堆的性质。
    heapify(arr, n, i);
  }

  // 排序阶段：反复提取堆顶元素（即数组的第一个元素，它是当前堆中的最大值），并将其放到数组的末尾。
  // 每提取一次堆顶元素，堆的大小就减 1，直到堆中只剩下一个元素。
  for (let i = n - 1; i > 0; i--) {
    // 调用 swap 函数，将堆顶元素（索引为 0）和当前未排序部分的最后一个元素（索引为 i）交换位置。
    // 这样，当前的最大值就被放到了数组的末尾，成为已排序部分的一部分。
    swap(arr, 0, i);
    // 交换后，堆的结构可能被破坏，需要重新调整堆。
    // 此时，堆的大小变为 i，因为最后一个元素已经是排序好的，不需要再参与堆的调整。
    // 从根节点（索引为 0）开始调用 heapify 函数，重新构建最大堆。
    heapify(arr, i, 0);
  }

  // 返回排序后的数组，由于排序过程是在原数组上进行的，所以返回的是原数组的引用。
  return arr;
}

/**
 * 堆调整函数，用于将以索引 i 为根节点的子树调整为最大堆。
 * @param {Array} arr 数组，包含待调整的元素。
 * @param {number} n 堆的大小，即当前参与堆调整的元素个数。
 * @param {number} i 要调整的节点索引，从该节点开始向下调整，使其满足最大堆的性质。
 */
function heapify(arr, n, i) {
  // 假设当前节点（索引为 i）是父节点和其子节点中的最大值。
  let largest = i;
  // 计算当前节点的左子节点的索引，在完全二叉树中，左子节点的索引为 2 * i + 1。
  const left = 2 * i + 1;
  // 计算当前节点的右子节点的索引，在完全二叉树中，右子节点的索引为 2 * i + 2。
  const right = 2 * i + 2;

  // 检查左子节点是否存在（即左子节点的索引小于堆的大小），并且左子节点的值是否大于当前假设的最大值节点的值。
  // 如果满足条件，则更新最大值节点的索引为左子节点的索引。
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  // 检查右子节点是否存在（即右子节点的索引小于堆的大小），并且右子节点的值是否大于当前假设的最大值节点的值。
  // 如果满足条件，则更新最大值节点的索引为右子节点的索引。
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  // 如果最大值节点的索引不等于当前节点的索引，说明当前节点不是父节点和其子节点中的最大值。
  // 此时需要交换当前节点和最大值节点的值，并递归调用 heapify 函数，继续调整以最大值节点为根的子树。
  if (largest !== i) {
    // 调用 swap 函数，交换当前节点（索引为 i）和最大值节点（索引为 largest）的值。
    swap(arr, i, largest);
    // 递归调用 heapify 函数，对以最大值节点（索引为 largest）为根的子树进行调整，确保其满足最大堆的性质。
    heapify(arr, n, largest);
  }
}

/**
 * 交换数组中两个元素的位置
 * @param {Array} arr 数组
 * @param {number} i 第一个元素的索引
 * @param {number} j 第二个元素的索引
 */
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

// 调用案例
const unsortedArray = [34, 12, 45, 6, 89, 23];
console.log("排序前的数组:", unsortedArray);
const sortedArray = heapSort(unsortedArray);
console.log("排序后的数组:", sortedArray);
  </script>
</html>
