<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      class Node {
        constructor(key) {
          this.key = key;
          this.left = null;
          this.right = null;
        }
      }

      class BST {
        constructor() {
          this.root = null;
        }
        // insert(key) {
        //   console.log(`插入键值: ${key}`);

        //   if (this.root === null) {
        //     this.root = new Node(key);
        //   }
        //   let current = this.root;
        //   while (current !== null) {
        //     if (key < current.key) {
        //       current = current.left;

        //     } else {
        //       current = current.right;
        //     }
        //   }
        //   // console.log(current);
        //   // current = new Node(key);
        // }
        insert(key) {
          console.log(`插入键值: ${key}`);

          // 如果树为空，新节点成为根节点
          if (this.root === null) {
            this.root = new Node(key);
            console.log(`  ${key} 成为根节点`);
            return;
          }

          // 从根节点开始查找插入位置
          let current = this.root;
          let parent = null;

          // 遍历树找到插入位置
          while (current !== null) {
            parent = current; // 记录父节点

            if (key < current.key) {
              console.log(`  ${key} < ${current.key}，向左查找`);
              current = current.left; // 向左子树查找
            } else {
              console.log(`  ${key} >= ${current.key}，向右查找`);
              current = current.right; // 向右子树查找
            }
          }

          // 此时current为null，parent是要插入位置的父节点
          // 根据与父节点的大小关系决定插入位置
          if (key < parent.key) {
            parent.left = new Node(key);
            console.log(`  ${key} 成为 ${parent.key} 的左子节点`);
          } else {
            parent.right = new Node(key);
            console.log(`  ${key} 成为 ${parent.key} 的右子节点`);
          }
        },
        inOrderTraverse(node = this.root, callback = (key) => console.log(key)) {
          if (node !== null) {
            this.inOrderTraverse(node.left, callback);   // 遍历左子树
            callback(node.key);                          // 访问根节点
            this.inOrderTraverse(node.right, callback);  // 遍历右子树
          }
        }
      }
      let mytree = new BST();
      const insertValues = [15, 10, 20, 8, 12, 17, 25, 6, 11, 13, 27];
      insertValues.forEach((value) => {
        mytree.insert(value);
      });
      console.log(mytree);
    </script>
  </body>
</html>
