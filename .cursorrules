# 数据结构与算法教程项目 - Cursor 规则

## 项目概述
这是一个面向中级前端开发人员的数据结构与算法教程项目，包含16个章节，其中最后一章是100道LeetCode精选题目。

## 代码规范

### JavaScript 代码规范
- 使用 ES6+ 语法
- 使用 const/let，避免 var
- 函数命名使用驼峰式：`quickSort`, `binarySearch`
- 类名使用帕斯卡命名：`LinkedList`, `BinaryTree`
- 常量使用全大写：`MAX_SIZE`, `DEFAULT_CAPACITY`

### 注释规范
- 所有函数必须使用 JSDoc 注释
- **核心思想说明**：每个算法函数必须在注释中详细说明核心思想和解题思路
- **步骤注释**：复杂算法需要详细的步骤注释，关键逻辑必须有行内注释
- 时间复杂度和空间复杂度必须标注
- **算法思想模板**：

```javascript
/**
 * 快速排序算法
 *
 * 核心思想：
 * 分治法思想，选择一个基准元素，将数组分为两部分：
 * - 左部分：所有元素都小于等于基准
 * - 右部分：所有元素都大于基准
 * 然后递归地对左右两部分进行同样的操作
 *
 * 算法步骤：
 * 1. 选择基准元素（通常选择最后一个元素）
 * 2. 分区操作：重新排列数组，使基准元素到达最终位置
 * 3. 递归排序左右子数组
 *
 * @param {number[]} arr - 待排序数组
 * @param {number} left - 左边界索引
 * @param {number} right - 右边界索引
 * @returns {number[]} 排序后的数组
 * @time O(n log n) 平均情况，O(n²) 最坏情况
 * @space O(log n) 递归栈空间
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        // 分区操作，返回基准元素的最终位置
        const pivotIndex = partition(arr, left, right);

        // 递归排序左子数组
        quickSort(arr, left, pivotIndex - 1);
        // 递归排序右子数组
        quickSort(arr, pivotIndex + 1, right);
    }
    return arr;
}
```

## 文件结构规范

### 章节目录结构
```
第X章-章节名/
├── README.md          # 章节主要内容
├── 基础实现.js         # 数据结构基础实现
├── 算法实现.js         # 相关算法实现
├── 练习题.md          # 章节练习题（最多5道）
└── 解答.js            # 练习题解答
```

### 最后一章结构（力扣100题）
```
第16章-力扣100道常考面试题/
├── README.md
├── 简单题/
│   ├── 001-两数之和.js
│   ├── 002-xxx.js
│   └── ...
├── 中等题/
│   ├── 011-xxx.js
│   ├── 012-xxx.js
│   └── ...
└── 困难题/
    ├── 091-xxx.js
    ├── 092-xxx.js
    └── ...
```

## 内容编写规则

### Markdown 文件规范
- 使用中文标题和描述
- 代码块必须指定语言类型
- 包含时间复杂度和空间复杂度分析
- 提供可视化图表（ASCII艺术或描述）
- 包含实际应用场景

### JavaScript 文件规范
- 每个文件开头必须有文件说明注释
- **核心思想详解**：每个算法都要详细说明解题思路和核心思想
- **逐步注释**：关键代码行必须有解释注释
- 包含完整的测试用例
- 提供多种解法（如果适用）
- 错误处理和边界条件检查

### 练习题规范
- **数量限制**：每章练习题最多5道，确保质量而非数量
- **难度分布**：建议2道简单题 + 2道中等题 + 1道困难题
- **题目选择**：优先选择能体现本章核心算法思想的经典题目
- **循序渐进**：题目难度逐步递增，帮助巩固知识点

## LeetCode 题目选择标准

### 简单题（10道，10%）
- 适合巩固基础概念
- 常见面试入门题
- 如：两数之和、有效的括号、合并两个有序链表等

### 中等题（80道，80%）
- 核心算法思想体现
- 实际面试高频题目
- 涵盖各种数据结构和算法
- 如：三数之和、岛屿数量、最长回文子串等

### 困难题（10道，10%）
- 综合性强，考查深度
- 顶级公司面试题
- 算法思想的高级应用
- 如：合并K个排序链表、最短路径问题等

## 教学重点

### 前端相关性
- 强调算法在前端开发中的应用
- 结合实际业务场景举例
- 性能优化角度解释算法价值

### 渐进式学习
- 从简单到复杂
- 理论与实践结合
- 大量代码示例和练习

## 文件命名规则
- 章节目录：`第X章-章节名`
- LeetCode题目：`题号-题目名.js`
- 使用中文名称，便于理解

## 代码质量要求
- 所有代码必须可运行
- **详细的思想解释**：每个算法都要说明为什么这样设计
- **丰富的行内注释**：关键逻辑步骤都要有注释说明
- 包含完整测试用例
- 处理边界情况
- 代码风格统一
- 性能优化考虑

## 特殊注意事项
- 避免使用过于复杂的数学知识
- 重点解释算法思想而非技巧
- 提供多种思路和解法
- 注重实际应用价值
- **注释比代码更重要**：宁可注释详细，也不要让读者猜测算法思路

## README.md 编写规范

### 文件结构模式（参考第1章范本）

#### 1. 章节概述 📚
- **简洁描述**：用1-2句话说明该数据结构/算法的重要性
- **核心内容预览**：明确列出本章要讲解的核心算法思想
- **避免冗余**：不要有学习目标、学习路径等教学指导内容

#### 2. 基础方法介绍 🔧
- **API详解**：详细介绍该数据结构的常见方法和操作
- **完整示例**：每个方法都要有完整的代码示例，包含输入输出
- **分类归纳**：按功能分类（如访问、修改、查找、转换等）
- **实用性强**：选择最常用和最重要的方法进行讲解

#### 3. 数据结构间的关系 💡
- **相互转换**：说明与其他数据结构的转换方法
- **共同特性**：总结共有的特点和操作
- **使用场景**：简要说明何时使用哪种数据结构

#### 4. 核心算法思想 🎯
- **概念定义**：用文字清晰定义算法思想的核心概念
- **解题思想**：详细解释为什么这样设计，解决了什么问题
- **应用场景**：明确说明什么时候使用这种算法
- **经典应用**：每个算法思想提供2-3个完整的代码示例

#### 5. 算法思想总结 🎯
- **复杂度对比**：用表格对比不同方法的时间复杂度
- **设计思想**：总结各算法的核心设计理念
- **适用总结**：一句话概括何时使用哪种算法

### 代码示例规范

#### 代码完整性
```javascript
// ✅ 正确示例：完整可运行的代码
function isPalindrome(s) {
    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');
    let left = 0, right = cleaned.length - 1;

    while (left < right) {
        if (cleaned[left] !== cleaned[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

// 调用示例
console.log(isPalindrome("A man a plan a canal Panama"));  // true

// ❌ 错误示例：省略版本
function twoPointers(arr) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        // 根据条件移动指针...
    }
}
```

#### 注释规范
- **核心思想**：每个函数开头用文字描述核心思想
- **参数说明**：简要说明参数作用
- **关键步骤**：重要逻辑行要有行内注释
- **调用示例**：提供实际的调用示例和输出结果

#### 概念解释规范
- **定义先行**：先给出概念的准确定义
- **原理解释**：用文字说明为什么这样设计
- **数学原理**：如涉及数学，要解释清楚（如前缀和的区间计算）
- **适用场景**：明确说明使用条件和场景

### 避免的内容
- ❌ 学习路径、学习建议、扩展阅读等教学指导
- ❌ 面试题型分类和应试技巧
- ❌ 过多的前端应用场景示例
- ❌ 省略的代码模板和伪代码
- ❌ 冗余的表情符号和装饰性内容

### 目标读者定位
- 🎯 **中级前端开发者**：有一定编程基础，理解基本概念
- 🎯 **概念理解为主**：重点解释算法思想和设计原理
- 🎯 **实用性导向**：提供完整可用的代码示例
- 🎯 **深度适中**：避免过浅的科普和过深的理论证明

## 力扣题目文档模板规范

### 文档结构标准（基于最长回文子串模板）

力扣文件夹下的所有算法题目文档必须遵循以下统一结构模板：

#### 1. 标题和题目描述 🎯
```markdown
# 题目名称问题 🌟

## 🎯 题目描述
- 清晰描述问题要求
- 列出具体的功能需求
- 提供约束条件

**要求**：
- 具体要求点1
- 具体要求点2
- 边界情况说明

**示例**：
```javascript
// 示例 1
输入: xxx
输出: xxx

// 示例 2-4（至少3-4个示例）
...
```
```

#### 2. 我的原始方法 💡
```markdown
## 💡 我的原始方法

### 思路分析
用户的原始想法是：
1. 步骤1描述
2. 步骤2描述
3. 步骤3描述
4. 步骤4描述

### 原始代码
```javascript
// 保留用户的原始代码，保持原样
// 包含所有原始的变量命名和逻辑
function originalFunction() {
    // 原始实现...
}
```

### 算法优点
- ✅ **优点1**：具体描述
- ✅ **优点2**：具体描述
- ✅ **优点3**：具体描述

### 存在的问题
- ❌ **问题1**：具体说明
- ❌ **问题2**：具体说明
- ❌ **问题3**：具体说明
```

#### 3. 改进版本 🔧
```markdown
## 🔧 改进版本

### 优化思路
1. 优化点1的详细说明
2. 优化点2的详细说明
3. 优化点3的详细说明
4. 优化点4的详细说明

### 改进代码
```javascript
/**
 * 算法名称（改进版）
 *
 * 核心思想：
 * 详细解释核心思想和设计理念
 *
 * @param {type} param - 参数说明
 * @returns {type} 返回值说明
 * @time O(x) 时间复杂度
 * @space O(x) 空间复杂度
 */
function improvedFunction(param) {
    // 边界条件处理
    if (边界条件) {
        return 边界处理;
    }

    // 核心算法逻辑
    // 每个关键步骤都要有注释说明

    // 统计和调试信息（可选）
    console.log(`📊 统计信息:`);

    return result;
}

// 辅助函数（如果需要）
function helperFunction() {
    // 详细注释
}

// 完整测试函数
function testFunction() {
    const testCases = [
        {
            input: "输入值",
            expected: ["期望值"],
            description: "测试场景描述"
        },
        // 更多测试用例...
    ];

    // 测试执行逻辑
}
```

### 改进亮点
- ✅ **改进点1**：具体说明
- ✅ **改进点2**：具体说明
- ✅ **改进点3**：具体说明
```

#### 4. 推荐的最佳方法 🌟
```markdown
## 🌟 推荐的最佳方法

### 方法一：算法名称（面试推荐）
```javascript
/**
 * 算法描述
 *
 * 核心思想：算法核心思想详细说明
 *
 * @param {type} param - 参数
 * @returns {type} 返回值
 * @time O(x) 时间复杂度
 * @space O(x) 空间复杂度
 */
function bestMethod1(param) {
    // 实现代码，包含详细注释
}
```

### 方法二：其他优秀方法
```javascript
// 其他算法实现...
```

### 方法三：高级算法（如果适用）
```javascript
// 高级算法实现...
```

### 方法四：基于原始思路的优化
```javascript
/**
 * 算法名称 - 基于用户原始思路的优化版本
 *
 * @param {type} param - 参数
 * @returns {type} 返回值
 * @time O(x) 时间复杂度
 * @space O(x) 空间复杂度
 */
function optimizedOriginalApproach(param) {
    // 保持原始思路但进行技术优化
}
```
```

#### 5. 复杂度分析表 📊
```markdown
## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 | 适用场景 |
|------|------------|------------|------|------|----------|
| 原始方法 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
| 改进方法 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
| 最佳方法1 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
| 最佳方法2 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
| 高级算法 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
| 优化原思路 | O(x) | O(x) | 优点描述 | 缺点描述 | 使用场景 |
```

#### 6. 知识点总结 🎓
```markdown
## 🎓 知识点总结

### 核心概念
1. **概念1**：定义和说明
2. **概念2**：定义和说明
3. **概念3**：定义和说明
4. **概念4**：定义和说明

### 关键技巧
- **技巧1**：具体说明
- **技巧2**：具体说明
- **技巧3**：具体说明
- **技巧4**：具体说明

### 实际应用
1. **应用场景1**：具体说明
2. **应用场景2**：具体说明
3. **应用场景3**：具体说明
4. **应用场景4**：具体说明
```

#### 7. 常见陷阱 🚨
```markdown
## 🚨 常见陷阱

### 陷阱类型1
```javascript
// ❌ 错误：错误做法说明
function wrongApproach() {
    // 错误代码示例
}

// ✅ 正确：正确做法说明
function correctApproach() {
    // 正确代码示例
}
```

### 陷阱类型2
```javascript
// 更多陷阱示例...
```
```

#### 8. 学习心得 💭
```markdown
## 💭 学习心得

### 对你的算法评价
1. **评价点1** ✅：具体评价
2. **评价点2** ✅：具体评价
3. **评价点3** ✅：具体评价
4. **改进空间** 🔄：具体建议

### 优化建议
1. **建议1**：具体说明
2. **建议2**：具体说明
3. **建议3**：具体说明
4. **建议4**：具体说明

### 解题模板
```javascript
function templateFunction(param) {
    // 1. 边界检查
    if (边界条件) return 边界值;

    // 2. 选择算法
    // 核心算法逻辑模板

    return result;
}
```

### 面试要点
- 🎯 **要点1**：具体说明
- 🎯 **要点2**：具体说明
- 🎯 **要点3**：具体说明
- 🎯 **要点4**：具体说明

### 实际应用场景
- 🔧 **场景1**：具体应用
- 📊 **场景2**：具体应用
- 🎮 **场景3**：具体应用
- 🌐 **场景4**：具体应用

---
*学习日期：年份 | 难度：⭐⭐⭐☆☆*
```

### 力扣文档编写要求

#### 内容要求
1. **保持原始代码**：用户的原始实现必须完整保留，包括变量命名和代码风格
2. **多种解法对比**：至少提供4-6种不同的解决方案
3. **基于原始思路优化**：必须包含基于用户原始思路的优化版本
4. **详细的复杂度分析**：用表格形式对比所有方法
5. **实用的测试用例**：提供完整的测试函数和多种测试场景
6. **丰富的注释**：每个算法都要有详细的JSDoc注释和步骤说明

#### 代码要求
1. **完整可运行**：所有代码示例都必须是完整的、可以直接运行的
2. **注释详细**：核心思想、参数说明、复杂度标注都要齐全
3. **错误处理**：包含边界条件检查和错误处理
4. **调试信息**：适当添加console.log用于调试和学习
5. **性能统计**：在改进版本中添加性能测试和统计信息

#### 格式要求
1. **统一emoji使用**：🎯🌟💡🔧📊🎓🚨💭等按固定含义使用
2. **表格规范**：复杂度分析必须用表格形式
3. **代码块标注**：所有代码块必须标注语言类型
4. **层次清晰**：使用明确的标题层次和缩进
5. **视觉友好**：合理使用✅❌🔄等符号增强可读性

#### 评价标准
1. **客观评价**：对用户原始算法进行客观、专业的评价
2. **建设性建议**：提供具体的改进建议和优化方向
3. **鼓励性语言**：在指出问题的同时，要肯定用户的思路和努力
4. **教学导向**：重点关注学习价值和知识点梳理
5. **实用性强**：提供面试和实际应用的指导建议

#### 特殊要求
- **避免过度批评**：重点关注改进和学习，而非批评原始代码
- **保持技术深度**：提供多种解法，包括高级算法（如适用）
- **注重应用场景**：结合实际开发和面试需求
- **持续优化意识**：从暴力解法到最优解法的渐进式学习路径